#### 第一周

###  常见编码

#### 字母表编码

A-Z/a-z 对应 1-26 或者 0-25

#### ASII 编码

##### 特点 

我们一般使用的ascii编码采用的都是可见字符，主要是一下字符

- 0-9, 48-57
- A-Z, 65-90
- a-z, 97-122

##### 变形

###### 二进制编码

将ascii 码对应的数字换成二进制表示形式。

- 只有 0 和 1
- 不大于 8 位，一般 7 位也可以，因为可见字符到 127。
- 其实是另一种 ascii 编码。

###### 十六进制编码

将 ascii 码对应的数字换成十六进制表示形式。

- A-Z→0x41~0x5A
- a-z→0x61~0x7A

##### 工具

- http://www.ab126.com/goju/1711.html

#### base 编码

base xx 中的 xx 表示的是采用多少个字符进行编码，比如说 base64 就是采用以下 64 个字符编码，由于 2 的 6 次方等于 64，所以每 6 个比特为一个单元，对应某个可打印字符。3 个字节就有 24 个比特，对应于 4 个 Base64 单元，即 3 个字节需要用 4 个可打印字符来表示。它可用来作为电子邮件的传输编码。在 Base64 中的可打印字符包括字母 A-Z、a-z、数字 0-9，这样共有 62 个字符，此外两个可打印符号在不同的系统中而不同。

##### base 64

1. 将每3个字节作为一组，3个字节一共24个二进制位
2. 将这24个二进制位分为4组，每个组有6个二进制位
3. 在每组的6个二进制位前面补两个00，扩展成32个二进制位，即四个字节
4. 每个字节对应的将是一个小于64的数字，即为字符编号
5. 再根据字符索引关系表，每个字符编号对应一个字符，就得到了Base64编码字符

在计算字节数时，会直接使用总长度除以3，如果余数为1则会直接在最后补一个`=`，如果余数为2则补两个`=`。

base64 仅可以ASCII字符编码，如果是中文字符等非ASCII码，需要先转ASCII编码后再进行编码。

Base64算是最为常见，开始出现斜线和加号，同时包括所有大小写字母和数字组合：**A-Z a-z 0-9 +/=**

ZmxhZ3tJc19DcnlwdDBncjRwaHlfMW50ZXJFc3Qhbmc/fQ==

原文本：hello world!
经过Base64编码后：aGVsbG8gd29ybGQh
原文本：hello world
经过Base64编码后：aGVsbG8gd29ybGQ=

##### base32

和Base64原理相似。由于 2^5=32，所以每5个比特为一个单元，对应某个可打印字符。5个字节有40个比特，对应于8个Base32单元，即5个字节可由8个可打印字符来表示。
 在Base64中的可打印字符包括字母`A-Z`、数字`2-7`，这样共有32个字符。若原数据长度不是5的倍数时且剩下1个输入数据，则在编码结果后加4个`=`；若剩下2个输入数据，则在编码结果后加3个`=`，以此类推。

原文本：hello world!
 经过Base64编码后：NBSWY3DPEB3W64TMMQQQ==
 原文本：hello world
 经过Base64编码后：NBSWY3DPEB3W64TMMQ====

##### base16

由于 ![2^{4}=16](https://math.jianshu.com/math?formula=2%5E%7B4%7D%3D16)，所以每4个比特为一个单元，对应某个可打印字符。1个字节有8个比特，对应于8个Base16单元，即1个字节可由2个可打印字符来表示。
 在Base64中的可打印字符包括字母`A-F`、数字`0-9`，这样共有16个字符。

原文本：hello world!
经过Base64编码后：68656C6C6F20776F726C64EFBC81

[base在线编码解码](https://links.jianshu.com/go?to=http%3A%2F%2Fctf.ssleye.com%2Fbase64.html)

##### 特点

- base64 结尾可能会有 `=` 号，但最多有 2 个
- base32 结尾可能会有 `=` 号，但最多有 6 个
- 根据 base 的不同，字符集会有所限制
- 有可能需要自己加等号
- 也就是 3D

Base编码系列有 Base64 Base32 Base16等等。
我们可以根据其中出现的一些特征来区分不同的base编码：

①所谓的**Base16其实就是16进制**，我们可以借助print(int(s16,16))将base16转换为10进制以进行其他运算：**0-9 A-F**

②Base32的特征比较明显：**A-Z 2-7 =**

 比如 cryptoisinteresting 的Base32编码就是MNZHS4DUN5UXG2LOORSXEZLTORUW4ZY=

③Base64算是最为常见，开始出现斜线和加号，同时包括所有大小写字母和数字组合：**A-Z a-z 0-9 +/=**

 如果某题的flag为flag{Is_Crypt0gr4phy_1nterEst!ng?}，用base64编码就可以得到ZmxhZ3tJc19DcnlwdDBncjRwaHlfMW50ZXJFc3Qhbmc/fQ==

除了上述三种常见的base编码，还存在：

base45（0-9A-Z $%*+-./:）

base58（没有0O大写i小写l和+/，后面没有等于号）

base85（!-u奇怪字符多，但是很少等号）

base91（除了 **-\‘** 的其他91种字符）

等其他种类编码，做题时如果实在无法确定可以都试一试。

⑤base100编码：指对**Emoji表情符号**进行编码和解码。

 如新生平台web题目组合拳😈中，三层waf破解后的👜👤👘👥👦👥🐥👧👟👧用base100解码可以得到emanon.php。

#### url编码

URL编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符，所以如果看到出现大量的百分号形式不妨尝试用url解码。

#### unicode编码

Unicode编码有多种种类：

原文本：hello

四种编码方式：

&#x 十六进制：&#x0068;&#x0065;&#x006C;&#x006C;&#x006F;

&# 十进制：&#00104;&#00101;&#00108;&#00108;&#00111;

\U 十六进制：\U0068\U0065\U006C\U006C\U006F

\U+ 十六进制：\U+0068\U+0065\U+006C\U+006C\U+006F

#### uuencode

Uuencode是二进制信息和文字信息之间的转换编码，也就是机器和人眼识读的转换。Uuencode编码方案常见于电子邮件信息的传输，目前已被多用途互联网邮件扩展（MIME）大量取代。

Uuencode加密后的数据结果都为可打印字符。

#### 摩斯密码

摩斯密码（摩尔斯电码）只有01或.-，会有空格或/做分隔符。

cyberchef

#### 栅栏密码

这是**移动字符位置**来实现加密的方法，加密方法大致如下：

 我们让一串字符串为 cryptoisgood，以key=2的方式进行加密：

 按照key分组，分成crypto和isgood两组。

 竖着列开每组分别取字重新组合，加密得到cirsygpotood

 如果key=3时，分成cryp tois good三组。

 竖着列开每组分别取字重新组合，加密得到ctgrooyiopsd

当题目中出现乱序的字母和{}甚至是 _ 和数字时都可以尝试栅栏密码。

#### 文件识别

1.file命令

可以再kali中利用file看一些没有后缀的文件.



2.可以利用010Editor

可以看文件头以及文件尾部

文件头

|        文件类型        |     文件头     |
| :--------------------: | :------------: |
|       JPEG(jpg)        |    FFD8FFE1    |
|        PNG(png)        |    89504E47    |
|       GIF (gif)        |    47494638    |
|       TIFF (tif)       |    49492A00    |
|  Windows Bitmap (bmp)  |    424DC001    |
|   ZIP Archive (zip)    |    504B0304    |
|   RAR Archive (rar)    |    52617221    |
| Adobe Photoshop (psd)  |    38425053    |
| Rich Text Format (rtf) |   7B5C727466   |
|       XML (xml)        |   3C3F786D6C   |
|  Adobe Acrobat (pdf)   | 355044462D312E |
|      Wave （wav）      |    57415645    |
|      pcap (pacp)       |    4D3C2B1A    |

一些常见文件尾部

- zip文件尾部以一串504B0506开始
- rar文件以C 43DB00400700结尾
- JPG文件结尾的FFD9
- PNG文件 结尾为000049454E44AE426082
- Gif文件结尾为3B



#### 文件分离 

文件分离有许多方法。

#####  Binwalk

是一个自动提取文件系统，该工具可以自动完成指定文件的扫描，发现潜藏在文件中中所有可疑的文件类型以及文件系统。

binwalk +file 扫描发现目标文件中包含的所有可识别的文件类型

binwalk +file -e 提取文件

提取成功的话则会生成一个文件名extracted目录，目录中存放的就是提取的文件

##### foremost

foremost是基于文件开始格式，文件结束标志和内部数据结构进行恢复文件的程序。该工具通过分析不同类型文件的头、尾和内部数据结构，同镜像文件的数据进行比对，以还原文件。它默认支持19种类型文件的恢复。用户还可以通过配置文件扩展支持其他文件类型。

有时候binwalk无法正确分离出文件，这时候就可以使用foremost，将目标文件复制到kali中，在终端中使用命令行进入文件所在文件夹，使用如下命令：
Foremost+file –o 输出目录名。

foremost分离得到的文件存放在output文件夹下

成功后可以再目标文件目录下生成我们设置的目录

##### dd

该工具是自动化分离工具，用在当题目文件包含其他文件时，可以把其他文件分离出来的一款工具。

dd if=源文件名 bs=1 skip=开始分离的字节数 of=目标文件名

参数说明

if=file    输入文件名，缺省为标准输入

of=file    输出文件名，缺省为标准输出

bs=bytes    同时设置读写块的大小为bytes，可代替ibs和obs。

skip=blocks    从输入文件开头跳过blocks个块后再开始复制

##### fcrackzip

是一款专门破解zip类行压缩文件密码工具

-b ---表示使用暴力破解的方法

-c ---'aA1'表示使用大小写字母和数字混合破解方式

-l  ---1-10表示需要破解的密码长度为1-10位

-u ---表示只显示破解出来的密码，其他错误密码不显示

使用字典爆破：

fcrackzip -D -p /usr/share/wp -u ????.zip

-D ---使用字典爆破
-p ---使用哪一个字典，后跟上路径或者字典的名字

#### 文件合并  

###### Linux下的合并

cat是linux系统下的一个能提取文件的内容的命令，使用cat命令将文件内容提取出来再导入目标文件

cat test1 test2 test3 > book

将 test1 test2 test3合并到book文件中.

------

cat test* > book

将test开头的所有文件按文件名从小到大的顺序合并，输出的book文件中。

------

md5sum 文件名

MD5加密

###### Windows下的合并

copy /B test1.txt+test2.txt+test3.txt book.txt

从左到右的顺序合并，输出book.txt

------

copy /B test.txt* book.txt

从小到大的顺序合并，输出book.txt

------

certutil -hashfile 文件名 md5

MD5加密

事实上，所有的文件都是以二进制的形式进行存储的，本质上没有差别。之所以使用的方法不同，只是因为我们理解他的方式不同。在每一个文件（包括图片，视频或其他的非ASCII文件）的开头（十六进制表示）实际上都有一片区域来显示这个文件的实际用法，这就是文件头标志。

#### 图片文件

JPEG (jpg)，文件头：FFD8FF

PNG (png)，文件头：89504E47

GIF (gif)，文件头：47494638

TIFF (tif)，文件头：49492A00

#### 压缩包文件

- ZIP Archive (zip) 文件头：`50 4B 03 04` 文件尾：`50 4B`
- RAR Archive (rar) 文件头：`52 61 72 21`

#### 音频文件

- Wave (wav) 文件头：`57 41 56 45`
- audio(Audio) 文件头： `4D 54 68 64`
- audio/x-aac（aac）
- 文件头：`FF F1(9)`

### zip加密文件

#### 文件结构

`ZIP` 文件主要由三部分构成，分别为

| 压缩源文件数据区                                | 核心目录          | 目录结束                        |
| :---------------------------------------------- | :---------------- | :------------------------------ |
| local file header + file data + data descriptor | central directory | end of central directory record |

- 压缩源文件数据区中每一个压缩的源文件或目录都是一条记录，其中
  - `local file header` ：文件头用于标识该文件的开始，记录了该压缩文件的信息，这里的文件头标识由固定值 `50 4B 03 04` 开头，也是 `ZIP` 的文件头的重要标志
  - `file data` ：文件数据记录了相应压缩文件的数据
  - `data descriptor` ：数据描述符用于标识该文件压缩结束，该结构只有在相应的 `local file header` 中通用标记字段的第 `3 bit` 设为 `1` 时才会出现，紧接在压缩文件源数据后
- `Central directory` 核心目录
- 记录了压缩文件的目录信息，在这个数据区中每一条纪录对应在压缩源文件数据区中的一条数据。

- `End of central directory record(EOCD)` 目录结束标识
- 目录结束标识存在于整个归档包的结尾，用于标记压缩的目录数据的结束。每个压缩文件必须有且只有一个 `EOCD` 记录。

#### 主要攻击

##### 爆破

###### Linux下的工具 fcrackzip

－b 指定模式为暴破，-c1指定密码类型为纯数字，其它类型可以rtfm,-u这个参数非常重要不然不显示破解出来的密码,-l 5-6可以指定长度 root@kali:fcrackzip -b -c1 -u test.zip



#### CRC32

##### 原理

`CRC` 本身是「冗余校验码」的意思，`CRC32` 则表示会产生一个 `32 bit` ( `8` 位十六进制数) 的校验值。由于 `CRC32` 产生校验值时源数据块的每一个 `bit` (位) 都参与了计算，所以数据块中即使只有一位发生了变化，也会得到不同的 `CRC32` 值。

`CRC32` 校验码出现在很多文件中比如 `png` 文件，同样 `zip` 中也有 `CRC32` 校验码。值得注意的是 `zip` 中的 `CRC32` 是未加密文件的校验值。

这也就导致了基于 `CRC32` 的攻击手法。

- 文件内内容很少 (一般比赛中大多为 `4` 字节左右)
- 加密的密码很长

我们不去爆破压缩包的密码，而是直接去爆破源文件的内容 (一般都是可见的字符串)，从而获取想要的信息。

 在爆破时我们所枚举的所有可能字符串的 `CRC32` 值是要与压缩源文件数据区中的 `CRC32` 值所对应

```python
# -*- coding: utf-8 -*-

import binascii
import base64
import string
import itertools
import struct

alph = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/='

crcdict = {}
print "computing all possible CRCs..."
for x in itertools.product(list(alph), repeat=4):
    st = ''.join(x)
    testcrc = binascii.crc32(st)
    crcdict[struct.pack('<i', testcrc)] = st
print "Done!"

f = open('flag.zip')
data = f.read()
f.close()
crc = ''.join(data[14:18])
if crc in crcdict:
    print crcdict[crc]
else:
    print "FAILED!"
```



#### 明文攻击

##### 原理

- 一个加密的压缩文件
- 压缩文件的压缩工具，比如 `2345` 好压， `WinRAR` ， `7z` 。 `zip` 版本号等，可以通过文件属性了解。如果是 `Linux` 平台，用 `zipinfo -v` 可以查看一个 `zip` 包的详细信息，包括加密算法等
- 知道压缩包里某个文件的部分连续内容 (至少 `12` 字节)

如果你已经知道加密文件的部分内容，比如在某个网站上发现了它的 `readme.txt` 文件，你就可以开始尝试破解了。

首先，将这个明文文件打包成 `zip` 包，比如将 `readme.txt` 打包成 `readme.zip` 。

打包完成后，需要确认二者采用的压缩算法相同。一个简单的判断方法是用 `WinRAR` 打开文件，同一个文件压缩后的体积是否相同。如果相同，基本可以说明你用的压缩算法是正确的。如果不同，就尝试另一种压缩算法。

##### 工具

Linux下的PKCrack

Windows下的 ARCHPR







#### 伪加密

在上文 `ZIP` 格式中的 **核心目录区** 中，我们强调了一个叫做通用位标记 `(General purpose bit flag)` 的 `2` 字节，不同比特位有着不同的含义。

修改伪加密的方法：

- `16` 进制下修改通用位标记
- `binwalk -e` 无视伪加密
- 在 `Mac OS` 及部分 `Linux`(如 `Kali` ) 系统中，可以直接打开伪加密的 `ZIP` 压缩包
- 检测伪加密的小工具 `ZipCenOp.jar`
- 有时候用 `WinRar` 的修复功能（此方法有时有奇效，不仅针对伪加密）

#### 解码

1.  2i9Q8AtDo5oMZd6UQrvegggb4o9qMrcNk5syu5dCyGcXfoSwXhtujiJwDv

base58解码

flag{9B1BD979-39BF-48CD-B427-FF748A4C41E9}

2. Fa+33_&6M7_#+*Dl~Rqbm]5psR$/ix$qCgDFx4m6?42+Qw.S7wy=d`3H05EQ]Zoa+U,<q40S2Nx0TCmY8w;=0;@6xP+cj+EYWG?cO:suHUc.=8&S|wfcA_3X(M0/fb$R0X(Il)&GlNMX@DgXI#oxij{i5UkbO[iS[Op;F[2SI%%7Pmbp$i(dG![5tV<gmN1b3O(I.[me,6l<,mWo"/r=8.1v<1.Io^>aY%+JG[>uWNh*~E!RL#4J91*N@1KK]Z.Tti5zDun#>I3<gQWi6Re3Z`PH!Li.LP}pkw;d=[g@$Meigb2byfe0jopB+NdwOlAkpR(F+wZ*BJ6LLmSi9%xz(i#pxP//g,yiW2`Ei0hvePTYwDAdl,Td]m`pG

   先base91解码再base58解码然后base32

   最后三次base64解码。

3. 🐬👘🐭👛🐮🐯🐭🐯🐬👘🐪🐪🐮🐫🐫🐬🐫👝🐬🐫🐫👜🐫🐪🐫👜🐬🐫🐫👘🐫🐪🐬🐨🐭🐰🐪🐨🐫🐫🐬🐨🐮👘🐭🐮🐮🐯🐫👚🐬🐫🐬🐩🐫🐬🐬🐩🐫🐬🐬🐰🐮🐫🐬🐨🐬🐬🐬🐰🐮👘🐬🐨🐬🐪🐪🐧🐪🐬🐫👜🐬🐫🐭👚🐫🐬🐫👜🐭👘🐬🐭🐫🐮🐬🐩🐫🐫🐭👙🐪🐨🐫👜🐫🐫🐫👘🐪🐰

base100解码：

5a6d78685a3374454f544e434e544a4351693144517a67784c545245524559745155597a515330354e546c454e6a564752446b314e444a39

16进制转ascii ：ZmxhZ3tEOTNCNTJCQi1DQzgxLTREREYtQUYzQS05NTlENjVGRDk1NDJ9

base64解码：

```
flag{D93B52BB-CC81-4DDF-AF3A-959D65FD9542}
```

4. Zns5NkE1QS1FQjNsZzc5OEUtQ0Q0My1FOUE2M0Y4N31hMDQxLThEMDJD

   base64解码

f{96A5A-EB3lg798E-CD43-E9A63F87}a041-8D02C

#### misc1 （文件分割）

题目为一张图片.

在010发现结尾有PK猜测隐藏有zip文件.

在kali中使用binwalk进行检测

binwalk a.png

发现有End of Zip archive, footer length: 22

则利用foremost进行文件分割。

foremost a.png

生成的output文件夹里有zip文件。打开后得到flag

flag{E0D6DEE1-33F0-42E1-9609-ECDFFFE5276C}

#### misc3（明文攻击）

在两个zip文件里中都有secret.txt经过检测发现他们的crc冗杂值一样。

显而易见是一个明文攻击。

利用ARCHPR工具进行明文攻击。

2023/5/6 21:17:26 - ARCHPR 4.54 build 45 已启动
2023/5/7 14:43:08 - 文件“C:\Users\86157\Desktop\新建文件夹 (3)\misc3\Plain.zip”已打开。
2023/5/7 14:48:34 - 文件“C:\Users\86157\Desktop\新建文件夹 (3)\misc3\Plain.zip”已打开。
2023/5/7 14:48:34 - 明文攻击已开始
2023/5/7 15:00:00 - 加密密钥已成功恢复!
2023/5/7 15:00:00 - 口令已成功恢复!
2023/5/7 15:00:00 - 'w98d@ud' 是这个文件的一个有效口令

得到有效口令。进行读取flag.txt。

得到flag：

HDCTF{u_a_a_master_@_c0mpRe553d_PaCKe1s}



#### misc 2

经过检测发现是CRC32爆破利用网上找到的工具进行爆破

```
python crc32.py reverse 你的crc32密文（0x+CRC密文）
```

找到有意义的字符串.。

passwo 

rdisCl 

assica

lencry

........

根据脚本编写字典

```python
def main():
    f =open("1.txt","w")
    str1="Cl"
    list1=['7YwZ9V','A1mm5l','FeGnrO','IvV3TL','PMjs_f','WTmMuM','_B4rxq','assica','fjtWIJ','hekguD','o1Ad2g','pBYJdc','r3qiPv','s30XKo','yTADrF','ztJ71V']
    list2=['8soNqS','A5uh32','BeBjur','E1hi2Q','KsZdcW','MvS7Sq''OwGeb4','PIrvY8','SThIrp','ZBpGdU','bjqSNw','cj0bUn','eo91eH','lencry','o5Ya49',
'v3tmWK']
    list3=['3VK2Zg','5SBajA','AJpuRn','FSwKxE','K1N5jS','M4GfZu','O5S4k0','P6wk8d','XqL5YD','YmBXCI','aECLik','cyFR0v','ptioni','rHlq7t','wmnQDB','xb0PcU','ybqaxL']
    list4=['AKjKcy','BVptH1','FRmuIR','Ka6j7X','ND4JDn','SgZWO3','WcGVNP','_iQ5Bx','bYCMs4','c5qQli','d093GV','oKFBdr','shint6','wltouU']
    for i in list1:
        for k in list2:
            for l in list3:
                for m in list4:
                    str2 =str1+i+k+l+m
                    f.write(str2+"\n")
    f.close()
if __name__ == '__main__':
    main()
```



用ARCHPR工具字典进行爆破

最后组成密码Classicalencryptionishint6

打开flag.txt  得到

]cX^r:X\jXiV`jVm\ipV`ek\ijk`e^t

可知这是变异凯撒密码。

编写脚本：

```python
str1="]cX^r:X\jXiV`jVm\ipV`ek\ijk`e^t"
num =ord('f')-ord(']')
for i in range(0,len(str1)):
    print(chr(ord(str1[i])+num),end="")
```

解密得到

flag{Caesar_is_very_intersting}



#### 简单的图片隐写

用binwalk分析得出一个bzip，但是binwalk以及foremost都无法进行分离.

用zsteg发现隐藏的数据。找到隐藏数据的位置：extradata:0    

把隐藏数据分离到1.txt

zsteg -E “extradata:0” misc17.png > 1.txt

再用binwalk分离1.txt得到图片。

![image-20230507164239002](C:\Users\86157\AppData\Roaming\Typora\typora-user-images\image-20230507164239002.png)

#### JM的秘密

先用binwalk检查 然后foremost分解得到一个压缩包，然后010发现为伪加密。

修改之后得到terceS.piz,发现为zip的反转，截取下来16进制的字符串

写入脚本

```py
import binascii
s = "05 B4 30 40 41 00 90 00 80 00 2C 17 79 65 5F E3 DA 30 DC 00 00 00 E8 30 00 00 C0 00 00 00 37 56 36 27 56 47 13 33 E2 47 87 47 74 ED 1C 82 02 CF 14 DD 00 E4 90 92 D8 06 7A CE 02 AA 99 B3 84 0D 9F 7E 04 87 C3 9B BC 73 CE D6 0B 3C 29 5C 18 39 EF 41 E1 95 10 CA A6 17 B8 F5 30 30 3E A4 14 C1 98 50 CE 8B 88 47 BF E6 80 E1 04 14 FA CE 8A 27 AC A1 62 DC BB 25 3C B4 05 75 85 FA F5 DB 1E AA 53 99 6B D4 CB AD 9F E4 97 7B A2 08 34 2A 29 88 17 C8 EC 54 D9 A4 F3 18 49 8D 87 3B 63 D3 3D 8A DE 48 E2 D9 AB 50 75 C1 0D 18 A9 1B 5E 99 3E 4E 6F 6C 35 2F 30 70 F5 46 E1 58 EB F6 22 8E 69 46 9B C3 02 A0 FA 0A 34 77 62 94 9F DC D4 41 E8 03 EF 4E 04 59 E2 B8 CD 38 4E 14 1A C8 04 95 45 4E C7 0B 60 DD 0F 36 16 E5 12 A9 DD 00 14 1E F2 B9 2F C8 E7 EE 74 B7 43 05 B4 10 20 41 00 41 00 90 00 80 00 2C 17 79 65 5F E3 DA 30 DC 00 00 00 E8 30 00 00 C0 00 42 00 00 00 00 00 00 00 02 00 00 00 00 00 00 00 37 56 36 27 56 47 13 33 E2 47 87 47 A0 00 02 00 00 00 00 00 10 00 81 00 09 BE C3 DC AA 57 9D 10 B8 14 07 DE EA 57 9D 10 89 05 62 DC AA 57 9D 10 05 B4 50 60 00 00 00 00 10 00 10 00 E5 00 00 00 7F 00 00 00 00 00"
no=s.replace(" ","") #去空格
new_s = ""
str=''
for i in range(0, len(no), 2):  # 每两个相邻的字符组成一对
    new_s += no[i+1] + no[i]  # 将一对字符互换
data = binascii.unhexlify(new_s)  # 将十六进制字符串转换为二进制数据
with open("123.zip",'wb')as f:
   f.write(data)
```

得到一个压缩包，发现居然还要密码，看了一下，并不是伪加密，直接暴力破解得到密码'114514' 

打开之后得到一个txt：

Oh‌‌‌‌‍‬‌﻿,‌‌‌‌‌﻿‌﻿You‌‌‌‌‍‬﻿‌ ‌‌‌‌‍﻿‍‍‌‌‌‌‍‬‍‌find‌‌‌‌‍‌‬‌‌‌‌‌‍﻿‍‌ JM‌‌‌‌‍‍‬‌‌‌‌‌‍‍‍﻿‌‌‌‌‍‬﻿‌‌‌‌‌‌﻿‬‌'‌‌‌‌‍﻿‬‌‌‌‌‌‍‍‌‬s ‌‌‌‌‍‬﻿‌secret‌‌‌‌‌﻿‬‍‌‌‌‌‍﻿‍‍‌‌‌‌‍‍‍‌‌‌‌‌‌﻿‌﻿,‌‌‌‌‍‍‬‬‌‌‌‌‌﻿‌‌but‌‌‌‌‍‍‬‌‌‌‌‌‌﻿‌‬‌‌‌‌‌﻿‬‌ ‌‌‌‌‍﻿‍﻿‌‌‌‌‍‍‍‌‌‌‌‌‍‌‍‬‌‌‌‌‌﻿‬‍there‌‌‌‌‍‌‍﻿ ‌‌‌‌‍‬‌‬‌‌‌‌‍‬‬‬‌‌‌‌‍‍‌‬‌‌‌‌‍‍‌﻿is‌‌‌‌‍‬‍‬ nothing‌‌‌‌‍‍‌‍‌‌‌‌‌﻿﻿‍‌‌‌‌‌﻿﻿‍:)

零宽字符解密：

.c3ludHtXWl8xRl9uT3Z0X28wTF9GbjRSfQ==

base解码得到：synt{WZ_1F_nOvt_o0L_Fn4R}
