<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>web3</title>
      <link href="/2024/06/25/web3/"/>
      <url>/2024/06/25/web3/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="926a36dd281356a4e9e5f575caf4c248ddd9ce61dff069d7d926958fff119faa">3018172ee2736c63d764d1a21d17018dd8410d42e63754f8d54b722d524db9a32cd7a8e87f346146df71470fb31412929fc572bff814cc0800f3a74b6a0b9d138a731da021babfbc04eee965d15639d29fb1732a614b4fd3813eac7a359de22ed942b6c886c8f3d83b015517e887544c0ec6b7d3b9774d379f06e501e1f41c280b7b198527a7768793cd6d3d6aceaf6b17c345390861bcd01f85a4c88739e1afeee7ae29a383af430812e4a51a1f1d1ccbf819454ed2dfe48ff8fae5f9875b4abe92af3f09ee19a3fdb3323959156c00611bb5e5c9e9d57ded454b29361a83ed6ec0e8e600b469e540f3fb93fbd68a213adc275dbc6cab3e2e569c9efdd1bad0</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>test</title>
      <link href="/2024/06/25/test/"/>
      <url>/2024/06/25/test/</url>
      
        <content type="html"><![CDATA[<h3 id="test1"><a class="headerlink" href="#test1"></a>test1</h3><p>123456<br>123456</p><h6 id="test2"><a class="headerlink" href="#test2"></a>test2</h6><p>123456</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ERC20</title>
      <link href="/2024/06/11/ERC20/"/>
      <url>/2024/06/11/ERC20/</url>
      
        <content type="html"><![CDATA[<h3 id="概述"><a class="headerlink" href="#概述"></a>概述</h3><p>ERC是Ethereum Request for Comments的首字母缩写。它就像技术文档，定义了适用于一群想要利用以太坊生态系统的开发者和用户的方法、行为、创新和研究。ERC-20介绍了在以太坊区块链上创建可互换代币的代币标准，在该协议下的相同的代币完全一致。</p><p>ERC-20 提出了一个同质化代币的标准，换句话说，它们具有一种属性，使得每个代币都与另一个代币（在类型和价值上）完全相同。 例如，一个 ERC-20 代币就像以太币一样，意味着一个代币会并永远会与其他代币一样。</p><p>ERC-20（以太坊意见征求 20）由 Fabian Vogelsteller 提出于 2015 年 11 月。这是一个能实现智能合约中代币的应用程序接口标准。</p><p>ERC-20 的功能示例包括：</p><ol><li>将代币从一个帐户转到另一个帐户</li><li>获取帐户的当前代币余额</li><li>获取网络上可用代币的总供应量</li><li>批准一个帐户中一定的代币金额由第三方帐户使用</li></ol><p>如果智能合约实施了下列方法和事件，它可以被称为 ERC-20 代币合约，一旦部署，将负责跟踪以太坊上创建的代币。</p><h3 id="接口定义"><a class="headerlink" href="#接口定义"></a>接口定义</h3><p>&lt;!–code￼0–&gt;</p><h4 id="Transfer-事件"><a class="headerlink" href="#Transfer-事件"></a>Transfer 事件</h4><p>&lt;!–code￼1–&gt;</p><h4 id="Approval-事件"><a class="headerlink" href="#Approval-事件"></a>Approval 事件</h4><p>&lt;!–code￼2–&gt;</p><h4 id="totalSupply-函数"><a class="headerlink" href="#totalSupply-函数"></a>totalSupply 函数</h4><p>&lt;!–code￼3–&gt;</p><h4 id="balanceOf-函数"><a class="headerlink" href="#balanceOf-函数"></a>balanceOf 函数</h4><p>&lt;!–code￼4–&gt;</p><h4 id="transfer-函数"><a class="headerlink" href="#transfer-函数"></a>transfer 函数</h4><p>&lt;!–code￼5–&gt;</p><h4 id="transferFrom-函数"><a class="headerlink" href="#transferFrom-函数"></a>transferFrom 函数</h4><p>&lt;!–code￼6–&gt;</p><h4 id="allowance-函数"><a class="headerlink" href="#allowance-函数"></a>allowance 函数</h4><p>&lt;!–code￼7–&gt;</p><h4 id="approve-函数"><a class="headerlink" href="#approve-函数"></a>approve 函数</h4><p>&lt;!–code￼8–&gt;</p><h3 id="链接"><a class="headerlink" href="#链接"></a>链接</h3><p><a href="https://learnblockchain.cn/article/4506">https://learnblockchain.cn/article/4506</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>攻防世界</title>
      <link href="/2024/05/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/"/>
      <url>/2024/05/31/%E6%94%BB%E9%98%B2%E4%B8%96%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h3 id="pdf"><a class="headerlink" href="#pdf"></a>pdf</h3><p>移开图片，即可得到flag</p><h3 id="base64stego"><a class="headerlink" href="#base64stego"></a>base64stego</h3><p>伪加密，然后base64隐写</p><h3 id="流量分析2"><a class="headerlink" href="#流量分析2"></a>流量分析2</h3><p>发现text.txt文件，导出http<br>&lt;!–code￼0–&gt;</p><h3 id="神奇的Modbus"><a class="headerlink" href="#神奇的Modbus"></a>神奇的Modbus</h3><p>搜索modbus，然后追踪tcp流即可。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>计算机组成原理</title>
      <link href="/2024/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
      <url>/2024/05/29/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="第一章-计算机组成原理概述"><a class="headerlink" href="#第一章-计算机组成原理概述"></a>第一章 计算机组成原理概述</h2><h3 id="计算机发展历程"><a class="headerlink" href="#计算机发展历程"></a>计算机发展历程</h3><h4 id="计算机硬件的发展"><a class="headerlink" href="#计算机硬件的发展"></a>计算机硬件的发展</h4><p>计算机系统=硬件+软件<br>硬件的发展：</p><ol><li>第一代：使用电子管</li><li>第二代：使用晶体管</li><li>第三代：使用较小规模的集成电路</li><li>第四代：使用较大规模的集成电路</li></ol><h4 id="计算机软件的发展"><a class="headerlink" href="#计算机软件的发展"></a>计算机软件的发展</h4><h3 id="计算机系统层次结构"><a class="headerlink" href="#计算机系统层次结构"></a>计算机系统层次结构</h3><h4 id="计算机系统组成"><a class="headerlink" href="#计算机系统组成"></a>计算机系统组成</h4><p>计算机系统由硬件系统和软件系统共同构建起来</p><h4 id="计算机硬件的基本组成"><a class="headerlink" href="#计算机硬件的基本组成"></a>计算机硬件的基本组成</h4><p>程序存储：指令以代码的形式事先输入到计算机的主存储器中，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。即按地址访问并顺序执行指令。<br>计算机按此原理应有五大功能：数据传送功能、数据存储功能、操作控制功能、操作判断功能</p><h5 id="冯诺漫体系结构特点："><a class="headerlink" href="#冯诺漫体系结构特点："></a>冯诺漫体系结构特点：</h5><ol><li>计算机硬件由五大部分组成（存储器、运算器、控制器、输出设备、输入设备）</li><li>指令和数据以同等地位存于存储器，可按地址寻访</li><li>指令和数据以二进制表示</li><li>指令由操作码和地址码组成</li><li>存储程序</li><li>以运算器为中心</li></ol><p>早期的冯·诺依曼机以运算器为中心，且是单处理机，最根本的特征是采用“存储程序”原理，基本工作方式是控制流驱动方式！<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240612162828.png" alt loading="lazy"></p><h5 id="现代计算机的组织结构"><a class="headerlink" href="#现代计算机的组织结构"></a>现代计算机的组织结构</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240612162919.png" alt loading="lazy"></p><h5 id="计算机的功能部件"><a class="headerlink" href="#计算机的功能部件"></a>计算机的功能部件</h5><p>主机：主存、运算器、控制器<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240612163244.png" alt loading="lazy"><br>&lt;1&gt; 输入设备，是指将外部信息以计算机能读懂的方式输入进来，如键盘，鼠标等</p><p>&lt;2&gt; 输出设备，就是将计算机处理的信息以人所能接受的方式输出出来，比如显示屏，打印机。</p><p>&lt;3&gt; 存储器，存储器分为 主存储器(内存储器，CPU能直接访问)和 辅助存储器(外存储器，协助主存储器记忆更多的信息，辅助存储器的信息需要导入到主存储器中，才可以被CPU访问)。</p><p>主存储器的工作方式是按存储单元的地址进行存取，这种存取方式称为按地址存取方式<br>主存储器是由地址寄存器(MAR)，数据寄存器(MDR)，存储体，时序控制逻辑，地址寄存器存放访存地址，经过地址译码后找到所选的存储单元。数据寄存器，是存储器与其他部件的中介，用于暂存要从存储器读或写的信息。时序控制逻辑用于产生存储器操作所需的各种时序信号。在现代CPU，MAR和MDR是在CPU中的。<br>&lt;4&gt; 运算器，是计算机的运算单元，用于算术运算和逻辑运算<br>运算器的核心单元是算术逻辑单元(ALU)<br>&lt;5&gt; 控制器，控制器是计算机的指挥中心，有其指挥各部件自动协调第进行工作，现代计算机将运算器和控制器集成到一个芯片上，合成为中央处理器，简称CPU。有程序计数器(PC)、指令寄存器(IR)和控制单元(CU)。<br>一般将运算器和控制器集成到同一个芯片上，称为中央处理器(CPU)。CPU和主存储器共同构成主机，而除主机外的其他硬件装置(外存、I/O设备等)统称为外部设备，简称外设。</p><h4 id="计算机软件的分类"><a class="headerlink" href="#计算机软件的分类"></a>计算机软件的分类</h4><h5 id="系统软件和应用软件"><a class="headerlink" href="#系统软件和应用软件"></a>系统软件和应用软件</h5><p>计算机软件，一般分为系统软件和应用软件<br>系统软件包括 操作系统，数据库管理系统，语言处理系统(比如编译器)，分布式软件系统，网络软件系统，标准库系统，服务性系统(比如连接程序)。</p><p>应用软件包括各种科学计算类程序，工程设计类程序，数据统计与处理程序</p><h5 id="三个级别的语言"><a class="headerlink" href="#三个级别的语言"></a>三个级别的语言</h5><ol><li>机器语言。又称二进制代码语言，需要编程人员记忆每条指令的二进制编码。机器语言是计算机唯一可以直接识别和执行的语言。</li><li>汇编语言。汇编语言用英文单词或其缩写代替二进制的指令代码，更容易为人们记忆和理解。使用汇编语言编辑的程序，必须经过一个称为汇编程序的系统软件的翻译，将其转换为计算机的机器语言后，才能在计算机的硬件系统上执行。</li><li>高级语言。高级语言(如C、C++、Java等)是为方便程序设计人员写出解决问题的处理方案和解题过程的程序。通常高级语言需要经过编译程序编译成汇编语言程序，然后经过汇编操作得到机器语言程序，或直接由高级语言程序翻译成机器语言程序。</li></ol><p>由高级语言转换到汇编语言的过程叫做编译，由汇编语言转换到机器语言的过程叫做汇编，边翻译边执行的叫做解析。</p><p>机器语言是计算机唯一可以直接执行的语言，汇编语言用助记符编写，以便记忆。而正则语言是编译原理中符合正则文法的语言。</p><p>解释程序的特点是翻译一句执行一句，边翻译边执行：由高级语言转化为汇编语言的过程称为编译，把汇编语言源程序翻译成机器语言程序的过程称为汇编。</p><h3 id="计算机性能指标"><a class="headerlink" href="#计算机性能指标"></a>计算机性能指标</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240612180015.png" alt loading="lazy"></p><ol><li>机器字长：<br>计算机的位数，表示计算机进行一次整数运算所能处理的二进制数据的位数。计算机字长通常选为字节（8位）的整数倍，通常2，4，8倍。不同的计算机，字节可能不同。</li></ol><p>机器字长、指令字长、存储字长的区别和联系是什么？</p><p>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。<br>指令字长：一个指令字中包含的二进制代码的位数。<br>存储字长：一个存储单元存储的二进制代码的长度。等于MDR的位数， 它们都必须是字节的整数倍。<br>数据字长：数据总线一次能传送信息的位数，它可以不等于MDR的位数。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p><ol start="2"><li>数据通路带宽：<br>数据总线一次所能传送信息的位数</li><li>主存容量：<br>MAR的位数反应存储单元的个数。如MAR为16位，表示存储单元为2^16 = 64K;若MDR为32位，则存储容量为2^16x32.</li><li>运算速度：<br>吞吐量指系统在单位时间处理请求的数量。从用户观点看，它是评价计算机系统性能的综合参数！<br>CPU时钟周期。通常为节拍脉冲或T周期，即主频的倒数，它是CPU中最小的时间单位，每个动作至少需要1个时钟周期。</li></ol><p>主频(CPU时钟频率)。机器内部主时钟的频率，是衡量机器速度的重要参数。</p><p>CPU周期又称为机器周期，由多个时钟周期组成！<br>指令周期&gt;CPU周期&gt;时钟周期<br>CPI（Clock cycle Per Instruction），即执行一条指令所需的时钟周期数。</p><p>CPU执行时间，指运行一个程序所花费的时间。<br>CPU执行时间 = CPU时钟周期数/主频 = (指令条数xCPI)/主频<br>CPU的性能取决于三个要素:主频、CPI 、指令条数</p><p>IPS(Instructions Per Second) =主频/平均CPI，每秒执行多少指令</p><p>MIPS(Million Instructions Per Second)=即每秒执行多少百万条指令。</p><p>MFLOPS(Mega Floating-point Operations Per Second)=浮点操作次数/(执行时间x106),即每秒执行多少百万次浮点运算。</p><p>GFLOPS(Giga Floating-point Operations Per Second)=浮点操作次数/(执行时间x109)，即每秒执行多少十亿次浮点运算。</p><p>TFLOPS(Tera Floating-point Operations Per Second)=浮点操作次数/(执行时间x1012)，即每秒执行多少万亿次浮点运算。</p><h3 id="常见问题"><a class="headerlink" href="#常见问题"></a>常见问题</h3><p>1.同一个功能既可以由软件实现又可以由硬件实现吗？</p><p>软件和硬件是两种完全不同的形态，硬件是实体，是物质基础；软件是一种信息，看不见、摸不到。但在逻辑功能上，软件和硬件是等效的。因此，在计算机系统中，许多功能既可以由硬件直接实现，又可以在硬件的配合下由软件实现。<br>一个最大的区别就是，硬件实现比软件实现的速度快很多，但是成本也高！所以，芯片在流片之后，如果发现bug可以用软件修复就用软件修复！</p><p>2.翻译程序、汇编程序、编译程序、解释程序有什么差别？各自的特性是什么？</p><p>翻译程序是指把高级语言源程序翻译成机器语言程序（目标代码）的软件。<br>翻译程序有两种：一种是编译程序，它将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序，因此只要源程序不变，就无须重新翻译，请注意同一种高级语言在不同体系结构下，编译成目标程序是不一样的，目标程序与体系结构相关，但仍不是计算机硬件能够直接执行的程序。另一种是解释程序，它将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。所以解释程序的执行过程是翻译一句执行一句，并且不会生成目标程序。<br>汇编程序也是一种语言翻译程序，它把汇编语言源程序翻译为机器语言程序。汇编语言是种面向机器的低级语言，是机器语言的符号表示，与机器语言一一对应。<br>编译程序与汇编程序的区別：若源语言是诸如C、C++、Java等“高级语言”，而目标语言是诸如汇编语言或机器语言之类的“低级语言”，则这样的一个翻译程序称为编译程序。若源语言是汇编语言，而目标语言是机器语言，则这样的一个翻译程序称为汇编程序。</p><p>3.什么是透明性？透明是指什么都能看见吗？</p><p>在计算机领域中，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户而言，某个事物或属性是透明的”。这与日常生活中的“透明”概念(公开、看得见)正好相反。<br>例如，对于高级语言程序员来说，浮点数格式、乘法指令等这些指令的格式、数据如何在运算器中运算等都是透明的；而对于机器语言或汇编语言程序员来说，指令的格式、机器结构、数据格式等则不是透明的。<br>在CPU中，IR、MAR和MDR对各类程序员都是透明的。</p><p>4.机器字长、指令字长、存储字长的区别和联系是什么？</p><p>机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。<br>指令字长：一个指令字中包含的二进制代码的位数。<br>存储字长：一个存储单元存储的二进制代码的长度。等于MDR的位数， 它们都必须是字节的整数倍。<br>数据字长：数据总线一次能传送信息的位数，它可以不等于MDR的位数。</p><p>指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令，因此取指周期为机器周期的2倍；若指令字长等于存储字长，则取指周期等于机器周期。</p><p>早期的计算机存储字长一般和机器的指令字长与数据字长相等，因此访问一次主存便可取出一条指令或一个数据。随着计算机的发展，指令字长可变，数据字长也可变，但它们必须都是字节的整数倍。</p><p>请注意64位操作系统是指特别为64位架构的计算机而设计的操作系统，它能够利用64位处理器的优势。但64位机器既可以使用64位操作系统，又可以使用32位操作系统。而32位处理器是无法使用64位操作系统的。</p><p>5.计算机体系结构和计算机组成的区别和联系是什么？</p><p>计算机体系结构是指机器语言或汇编语言程序员所看得到的传统机器的属性，包括指令集、数据类型、存储器寻址技术等，大都属于抽象的属性。<br>计算机组成是指如何实现计算机体系结构所体现的属性，它包含对许多对程序员来说透明的硬件细节。例如，指令系统属于结构的问题，但指令的实现即如何取指令、分析指令、取操作数如何运算等都属于组成的问题。因此，当两台机器指令系统相同时，只能认为它们具有相同的结构，至于这两台机器如何实现其指令，完全可以不同，即可以认为它们的组成方式是不同的。例如，一台机器是否具备乘法指令是一个结构的问题，但实现乘法指令采用什么方式则是一个组成的问题。（简言之，看有没有这个属性，就是结构问题；看怎么实现，就是组成问题）<br>许多计算机厂商提供一系列体系结构相同的计算机，而它们的组成却有相当大的差别，即使是同一系列的不同型号机器，其性能和价格差异也很大。例如， IBM System/370结构就包含了多种价位和性能的机型。</p><p>6.基准程序执行得越快说明机器的性能越好吗？</p><p>一般情况下，基准测试程序能够反映机器性能的好坏。但是，由于基准程序中的语句存在频度的差异，因此运行结果并不能完全说明问题。<br>&lt;!-- ## 第二章 数据的表示与运算<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618102206.png" alt loading="lazy"></p><h3 id="数制与编码"><a class="headerlink" href="#数制与编码"></a>数制与编码</h3><h4 id="进制转换"><a class="headerlink" href="#进制转换"></a>进制转换</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618102507.png" alt loading="lazy"></p><h4 id="BCD码"><a class="headerlink" href="#BCD码"></a>BCD码</h4><p>是为了表示0和9，所以1010~1111都是违法的<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618102631.png" alt loading="lazy"></p><h4 id="字符与字符串"><a class="headerlink" href="#字符与字符串"></a>字符与字符串</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618102714.png" alt loading="lazy"></p><h4 id="校验码"><a class="headerlink" href="#校验码"></a>校验码</h4><h3 id="–"><a class="headerlink" href="#–"></a>–&gt;</h3><h2 id="第三章-系统总线"><a class="headerlink" href="#第三章-系统总线"></a>第三章 系统总线</h2><h3 id="总线的基本概念"><a class="headerlink" href="#总线的基本概念"></a>总线的基本概念</h3><p>计算机系统的五大部件之间的互联方式有两种，一种是各部件之间使用的单独连线，称为分散连接；一种使将各部件连到一组公共信息传输线上，称为总线连接。<br>（在某一时刻，只允许一个部件向总线发送信息，多个部件可以同时从总线上接受相同的信息。）<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618103743.png" alt loading="lazy"></p><h3 id="总线的分类"><a class="headerlink" href="#总线的分类"></a>总线的分类</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618104224.png" alt loading="lazy"></p><h4 id="连接部件"><a class="headerlink" href="#连接部件"></a>连接部件</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618104453.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618104435.png" alt loading="lazy"></p><ol><li>片内总线：指芯片内部的总线，如在CPU芯片内部，寄存器与寄存器之间、寄存器与算逻单<br>元ALU之间都由片内总线连接。</li><li>系统总线：是指CPU 、主存、I/O设备各大部件之间的信息传输线。。由于这些<br>部件通常都安放在主板或各个插件板（插卡）上，故又称板级总线（在一块电路板上各芯片间的连线）或板间总线。<br>按系统总线传输信息的不同，又可分为三类：数据总线、地址总线和控制总线。</li><li>通信总线：用于计算机系统之间或计算机系统与替他系统之间的通信。由于这类联系涉及许多方面，如外部连接、距离远近、速度快慢、工作方式等，差别极大，因此通信总线的类别很多。但按传输方式可分为两种：串行通信和并行通信。</li></ol><h3 id="总线特性及性能指标"><a class="headerlink" href="#总线特性及性能指标"></a>总线特性及性能指标</h3><h4 id="总线特性"><a class="headerlink" href="#总线特性"></a>总线特性</h4><p>机械特性、电气特性、功能特性、时间特性。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/23.png" alt loading="lazy"></p><h4 id="总线的性能指标"><a class="headerlink" href="#总线的性能指标"></a>总线的性能指标</h4><p>①总线宽度：通常是指数据总线的根数，用bit（位）表示，如8位、16位、32位、64位（即8根、16根、32根、64根）。<br>②总线带宽：总线带宽可理解为总线的数据传输速率，即单位时间内总线上传输数据的位数，通常用每秒传输信息的学节数来衡量，单位可用MBpS（兆节每秒）表示。例如，总线工作频率为33MHz，总线宽度为32位（4B），则总线带宽为33×（32/8）=132MBps。<br>③时钟同步/异步：总线上的数据与时钟同步工作的总线称为同步总线，与时钟不同步工作<br>的总线称为异步总线。<br>④总线复用：一条信号线上分时传送两种信号。例如，通常地址总线与数据总线在物理上<br>是分开的两种总线，地址总线传输地址码，数据总线传输数据信息。为了提高总线的利用率，优化设计，特将地址总线和数据总线共用一组物理线路，在这组物理线路上分时传输地址信号和数据信号，即为总线的多路复用。<br>⑤信号线数：地址总线、数据总线和控制总线三种总线数的总和。<br>⑥总线控制方式：包括突发工作、自动配置、仲裁方式、逻辑方式、计数方式等。<br>⑦其他指标：如负载能力、电源电压（是采用5V还是3.3V）、总线宽度能否扩展等。<br>总线的负载能力即驱动能力，是指当总线接上负载后，总线输人输出的逻辑电平是否能保持<br>在正常的额定范围内。</p><h4 id="总线标准"><a class="headerlink" href="#总线标准"></a>总线标准</h4><h3 id="总线结构"><a class="headerlink" href="#总线结构"></a>总线结构</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618105404.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618105409.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618105426.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618105449.png" alt loading="lazy"></p><h3 id="总线控制"><a class="headerlink" href="#总线控制"></a>总线控制</h3><p>包括判优控制和通信控制</p><h4 id="总线判优控制"><a class="headerlink" href="#总线判优控制"></a>总线判优控制</h4><p>总线上所连接的各类设备，按其对总线有无控制功能可分为主设备（模块）和从设备（模块）两种。主设备对总线有控制权，从设备只能响应丛主设备发来的总线命令，对总线没有控制权。<br>总线判优控制可分集中式和分布式两种，前者将控制逻辑集中在一一处（如在CPU中），后者将控制逻辑分散在与总线连接的各个部件或设备上。<br>常见的几种优先权仲裁方式</p><ol><li>链式查询<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618110139.png" alt loading="lazy"><br>离总线控制部件最近的设备具有最高的优先级。<br>特点：只需很少几根线就能按一定的优先次序实现总线控制，并很容易扩充设备，但是对电路故障很敏感，且优先级别低的设备可能很难获得请求。</li><li>计数器定时查询<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618110503.png" alt loading="lazy"><br>计数也以从上一次计数的终点开始。<br>这种方式对电路故障不如链式查询方式敏感。伯增加了控制线（设备地址）数，控制也较复杂。</li><li>独立请求方式<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240618110553.png" alt loading="lazy"><br>这种方式的特点是：响应速度快，优先次序控制灵活（通过程序改变），但控制线数量多，总线控制更复杂。</li></ol><h4 id="总线通信控制"><a class="headerlink" href="#总线通信控制"></a>总线通信控制</h4><p>总线通信控制主要解决通信双方如伺获知传输升始和传输结束，以及通信双方如伺协调如<br>何配合。<br>总线传输周期</p><p>①申请分配阶段：主模块申请，总线仲裁决定</p><p>②寻址阶段：主模块从模块给出地址和命令</p><p>③传数阶段：主模块和从模块交换数据</p><p>④结束阶段：主模块撤销有关信息<br>通常用四种方式：同步通信、异步通信、半同步通信和分离式通信。</p><h3 id="问题"><a class="headerlink" href="#问题"></a>问题</h3><ol><li>引入总线会导致什么问题？如何解决？</li></ol><p>引入总线后，总线上的各个设备分时共享同一总线，当总线上多个设备同时要求使用总线时就会导致总线的冲突。为解决多个主设备同时竞争总线控制权的问题，应当采用总线仲裁部件，以某种方式选择一个主设备优先获得总线控制权，只有获得了总线控制权的设备才能开始数据传送。</p><ol start="2"><li>引入总线结构有什么好处？</li></ol><p>引入总线结构主要有以下优点<br>①简化了系统结构，便于系统设计制造。<br>②大大减少了连线数目，便于布线，减小体积，提高系统的可靠性<br>③便于接口设计，所有与总线连接的设备均采用类似的接口。<br>④便于系统的扩充、更新与灵活配置，易于实现系统的模块化<br>⑤便于设备的软件设计，所有接口的软件对不同的接口地址进行操作。<br>⑥便于故障诊断和维修，同时也能降低成本。</p><h2 id="第四章-存储器"><a class="headerlink" href="#第四章-存储器"></a>第四章 存储器</h2><h3 id="概述"><a class="headerlink" href="#概述"></a>概述</h3><h4 id="存储器分类"><a class="headerlink" href="#存储器分类"></a>存储器分类</h4><p>按在计算机中的作用：</p><ol><li>主存储器，简称主存。CPU可直接随机地对其进行访问，也可以和高速缓存器及辅助存储器交换数据。</li><li>辅助存储器，简称辅存。CPU不能直接访问，用来存放当前暂时用不到的程序段和数据。</li><li>高速缓冲存储器，位于主存和CPU之间，用来存放正在执行的程序段和数据。</li></ol><p>按存储介质分类：<br>磁表面存储器（磁盘，磁带），磁心存储器半导体存储器（MOS型存储器，双极存储器）和光存储器（光盘）。</p><p>按存取方式：</p><ol><li>随机存取存储器（RAM）。存储器的任何一个存储单元的内容都可以随机存取，而且存取时间与存取单元的物理位置无关，主要用作主存或高速缓冲存储器。</li><li>只读存储器（ROM）存储器的内容只能随机读出而不能写入。即使断电，内容也不会丢失。</li><li>串行访问存储器。对存储单元进行读/写操作时，需按其物理位置的先后顺序寻址，包括顺序存取存储器（如磁带）与直接存取存储器（如磁盘）。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619154156.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619154204.png" alt loading="lazy"></li></ol><h4 id="存储器的性能指标"><a class="headerlink" href="#存储器的性能指标"></a>存储器的性能指标</h4><p>&lt;1&gt; 存储容量：存储字数*字长</p><p>&lt;2&gt; 单位成本：每位价格=总成本/总容量</p><p>&lt;3&gt; 存储速度：数据传输率=数据的宽度/存储周期<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619154624.png" alt loading="lazy"></p><h4 id="存储器的层次结构"><a class="headerlink" href="#存储器的层次结构"></a>存储器的层次结构</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619155055.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/2.png" alt loading="lazy"></p><h3 id="主存储器"><a class="headerlink" href="#主存储器"></a>主存储器</h3><h4 id="半导体随机存储器"><a class="headerlink" href="#半导体随机存储器"></a>半导体随机存储器</h4><h5 id="SRAM-和-DRAM"><a class="headerlink" href="#SRAM-和-DRAM"></a>SRAM 和 DRAM</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161159.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161435.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161504.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161514.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161526.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161543.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619161559.png" alt loading="lazy"></p><h5 id="只读存储器"><a class="headerlink" href="#只读存储器"></a>只读存储器</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163124.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163128.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163141.png" alt loading="lazy"></p><h5 id="主存储器与CPU的连接"><a class="headerlink" href="#主存储器与CPU的连接"></a>主存储器与CPU的连接</h5><p>主存容量的扩展：</p><ol><li>位扩展<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163333.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163345.png" alt loading="lazy"></li><li>字扩展<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163441.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163446.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163451.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163457.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163502.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163508.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163513.png" alt loading="lazy"></li><li>字位同时扩展<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163553.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240619163613.png" alt loading="lazy"></li></ol><h4 id="存储器的校验"><a class="headerlink" href="#存储器的校验"></a>存储器的校验</h4><p>汉明码的组成、汉明码的纠错过程</p><h4 id="提高访存速度的措施"><a class="headerlink" href="#提高访存速度的措施"></a>提高访存速度的措施</h4><p>单体多字系统、多体并行系统、高性能存储芯片</p><h3 id="高速缓冲器"><a class="headerlink" href="#高速缓冲器"></a>高速缓冲器</h3><h4 id="程序访问的局部性原理"><a class="headerlink" href="#程序访问的局部性原理"></a>程序访问的局部性原理</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240622092550.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240622092600.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/2312.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240622092612.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240622092617.png" alt loading="lazy"></p><h4 id="Cache的基本工作原理"><a class="headerlink" href="#Cache的基本工作原理"></a>Cache的基本工作原理</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240622092745.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240623103713.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240623103722.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240623103728.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240623103734.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240623103739.png" alt loading="lazy"></p><h4 id="替换策略"><a class="headerlink" href="#替换策略"></a>替换策略</h4><p>当新的主存块需要调入Cache并且它的可用空间位置又被占满时，需要替换掉Cache的数<br>据,这就产生了替换策略（算法）问题。在直接映射的 Cache 中,由于某个主存块只与一个Cache字块有映射关系，因此替换策略很简单。而在组相联和全相联映射的Cache中，主存块可以写入Cache 中若干位置,这就有一个选择替换掉哪一个 Cache 字块的问题,即所谓替换算法问题。理想的替换方法是把未来很少用到的或者很久才用到的数据块替换出来，但实际上很难做到。常用的替换算法有先进先出算法、近期最少使用算法和随机法。</p><p>1.先进先出（First-In-First-Out,FIFO）算法:最先被调用的可能是被频繁访问的。<br>2.近期最少使用（Least RecentlyUsed,LRU）算法：基于局部性原理，实际运行效果优秀，chche命中率高。<br>3.随机法：随机法是直接从Cache中随机选择一个Cache字块进行替换。<br>4.LFU算法：LFU算法是使用访问次数作为替换依据，即访问次数越少，被替换的概率越大。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/234weq.png" alt loading="lazy"></p><h4 id="写策略"><a class="headerlink" href="#写策略"></a>写策略</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/weqwe.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/qwrqw.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/sadad.png" alt loading="lazy"><br>操作频繁可能因为写缓冲饱和而发生阻塞。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/weqedas.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/adqwawd.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/3124234342.png" alt loading="lazy"></p><h3 id="辅助存储器"><a class="headerlink" href="#辅助存储器"></a>辅助存储器</h3><ol><li>辅助存储器的特点<br>辅助存储器作为主存的后援设备文称为外部存储器，简称外存，它与主存起组成厂存储器<br>系统的主存一辅存层次。与主存相比，辅存具有容量大、速度慢、价格低、可脱机保存信息等特点，属非易失性”存储器。而主存具有速度快、成本高、容量小等特点，而日大多由半导体芯片构成，所存信息无法永久保存，属“易失性”存储器。<br>目前，广泛用于计算机系统的辅助存储器有硬磁盘、软磁盘、磁带、光盘等。前三种均属磁表面存储器。<br>磁表面存储器是在不同形状（如盘状、带状等）的载体上涂有磁性材料层，工作时，靠载磁<br>体高速运动，由磁头在磁层上进行读/写操作，信息被记录在磁层上，这些信息的轨迹就是磁道。磁盘的磁道是个个同心圆.</li><li>磁表面存储器的主要技术指标<br>（1）记录密度<br>（2）存储容量<br>（3）平均寻址时间<br>（4）数据传输率<br>（5）误码率</li></ol><h3 id="问题-2"><a class="headerlink" href="#问题-2"></a>问题</h3><ol><li>存取时间Ta就是存储周期Tm吗？</li></ol><p>不是。存取时间Ta是执行一次读操作或写操作的时间，分为读出时间和写入时间。读出时间是从主存接收到有效地址开始到数据稳定为止的时间；写入时间是从主存接收到有效地址开始到数据写入被写单元为止的时间。<br>存储周期Tm是指存储器进行连续两次独立地读或写操作所需的最小时间间隔。所以存取时间Ta不等于存储周期Tm。通常存储周期Tm大于存取时间Ta。<br>2. Cache行的大小和命中率之间有什么关系？</p><p>行的长度较大，可以充分利用程序访问的空间局部性，使一个较大的局部空间被一起调到Cache中，因而可以增加命中机会。但是，行长也不能太大，主要原因有两个：<br>(1)行长大使失效损失变大。也就是说，若未命中，则需花更多时间从主存读块。<br>(2)行长太大， Cache项数变少，因而命中的可能性变小</p><ol start="3"><li>发生取指令 Cache缺失的处理过程是什么？</li></ol><p>(1)程序计数器恢复当前指令的值。<br>(2)对主存进行读的操作。<br>(3)将读入的指令写入 Cache中，更改有效位和标记位。<br>(4)重新执行当前指令。</p><ol start="4"><li>关于 Cache的一些小知识。</li></ol><p>(1)多级 Cache。现代计算机系统中，一般采用多级的 Cache系统。CPU执行指令时，先到速度最快的一级 Cache( LI Cache)中寻找指令或数据，找不到时，再到速度次快的二级Cache(L2 Cache)中找…最后到主存中找。<br>(2)指令 Cache和数据 Cache。指令和数据可以分别存储在不同的 Cache中（ LI Cache一般会这么做），这种结构也称哈佛 Cache,其特点是允许CPU在同一个 Cache存储周期内同时提取指令和数据，由于指令执行过程取指和取数据都有可能访问 Cache,因此这一特性可以保证不同的指令同时访存。</p><h2 id="第五章-输入输出系统"><a class="headerlink" href="#第五章-输入输出系统"></a>第五章 输入输出系统</h2><h3 id="概述-2"><a class="headerlink" href="#概述-2"></a>概述</h3><p>输入输出是以主机位中心谈论的！属于外部设备<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624103039.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624103103.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624103120.png" alt loading="lazy"><br>I/O设备不可能直接与主板总线相连，它总是通过设备控制器来相连的<br>I/O指令是指令系统的一部分，是机器指令的一类，但其为了反映与I/O设备交互的特点，格式和其他通用指令相比有所不同。<br>通道程序存放在主存而非通道中，由通道从主存中取出并执行。通道程序由通道执行，且只能在具有通道的I/O系统中执行</p><h4 id="I-O控制方式"><a class="headerlink" href="#I-O控制方式"></a>I/O控制方式</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624103626.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624184106.png" alt loading="lazy"></p><h3 id="I-O接口"><a class="headerlink" href="#I-O接口"></a>I/O接口</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185706.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240625171450.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185830.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185846.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185910.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185920.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185929.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624185952.png" alt loading="lazy"></p><h3 id="I-O方式"><a class="headerlink" href="#I-O方式"></a>I/O方式</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190208.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190229.png" alt loading="lazy"></p><h4 id="程序查询方式"><a class="headerlink" href="#程序查询方式"></a>程序查询方式</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190724.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190730.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190835.png" alt loading="lazy"></p><h4 id="程序中断方式"><a class="headerlink" href="#程序中断方式"></a>程序中断方式</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190859.png" alt loading="lazy"><br>计算机在执行程序的过程中，当出现异常情况或特殊请求时,计算机停止现行程序的运行，转向对这些异常情况或特殊请求的处理，处理结束后再返回到现行程序的间断处，继续执行原程序,这就是“中断”。中断是现代计算机能有效合理地发挥效能和提高效率的一个十分重要的功能。通常又把实现这种功能所需的软硬件技术统称为中断技术。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190934.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624190939.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191132.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191137.png" alt loading="lazy"></p><h4 id="DMA方式"><a class="headerlink" href="#DMA方式"></a>DMA方式</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191214.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191221.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191229.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191335.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191340.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191349.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191355.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240624191425.png" alt loading="lazy"></p><h2 id="参考链接"><a class="headerlink" href="#参考链接"></a>参考链接</h2><p><a href="https://blog.csdn.net/haojie_duan/article/details/112739522">https://blog.csdn.net/haojie_duan/article/details/112739522</a><br><a href="https://blog.csdn.net/weixin_65520839/article/details/134017151">https://blog.csdn.net/weixin_65520839/article/details/134017151</a></p>]]></content>
      
      
      <categories>
          
          <category> Education </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>现代密码学</title>
      <link href="/2024/05/29/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/"/>
      <url>/2024/05/29/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6/</url>
      
        <content type="html"><![CDATA[<h3 id="第一章-概述"><a class="headerlink" href="#第一章-概述"></a>第一章 概述</h3><h4 id="信息安全三要素"><a class="headerlink" href="#信息安全三要素"></a>信息安全三要素</h4><p>保密性： 使截获者在不知密钥条件下不能解读信息。<br>完整性：保证信息从真实的发送者传送到真实的接收者手中，传送过程中没有非法用户添加删除和替换<br>可用性：指保障信息资源随时可提供服务的能力特性/保证经过授权的客户能及时准确地不间断的访问数据。</p><h4 id="属性"><a class="headerlink" href="#属性"></a>属性</h4><p>认证性：使任何不知密钥的人不能构造一个密钥，使意定的接收者脱密成一个可理解的消息。<br>不可否认性：对出现的安全问题提供调查的依据和手段。使用审计、监控、防抵赖等安全机制，使得攻击者、破坏者、抵赖者“逃不脱&quot;，并进一步对网络出现的安全问题提供调查依据和手段，实现信息安全的可审查性</p><p>实时性</p><h4 id="kerckhoff-原则"><a class="headerlink" href="#kerckhoff-原则"></a>kerckhoff 原则</h4><p>Kerckhoff 原则： 系统的保密性不依赖与对加密提示或算法的保密，而依赖于密钥。</p><h4 id="密码分析"><a class="headerlink" href="#密码分析"></a>密码分析</h4><p>依据攻击者知道的信息多少，密码可能经受的不同水平的攻击：</p><p>唯密文攻击：分析者仅拥有的截获密文，试图进行分析得出明文或密钥。</p><p>已知明文攻击 ：分析者已有很多明文-密文对，试图进行分析得出明文或密钥。</p><p>选择明文攻击：分析者可以选定任何明文-密文对来进行攻击，以确定未知的密钥。</p><p>选择密文攻击：分析者可以任意选择密文，并可获得相应明文</p><p>CPA安全：CPA（Chosen-Plaintext Attack），选择明文攻击</p><p>密码可能经受的不同水平的攻击</p><h4 id="密钥体制分类"><a class="headerlink" href="#密钥体制分类"></a>密钥体制分类</h4><p>单钥体制：加密和解密密钥相同，主要问题是密钥产生和密钥管理包括流密码和分组密码。<br>双钥体制：加密和解密密钥不同，安全性可实现对A所发消息的验证<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921237.png" alt loading="lazy"></p><p>一般说来，加密算法很难达到“无条件安全”。因此在实际上只需满足两条准则即可，试给出这两条准则。<br>实际上需满足计算上安全：<br>1、破译密文的代价超过被加密信息的价值<br>2、破译密文多花的时间超过信息的有用期</p><h3 id="第二章-流密码"><a class="headerlink" href="#第二章-流密码"></a>第二章 流密码</h3><h4 id="基本概念和分类"><a class="headerlink" href="#基本概念和分类"></a>基本概念和分类</h4><p>流密码是将明文划分为字符，或其编码的基本单元，每一字符分别与密钥流对应字符“作用”，从而进行加密，解密时以同步产生的同样的密钥流实现。<br>流密码强度完全依赖于密钥流生成器生成的密钥流的随机性和不可预测性<br>流密码有记忆性，分组密码则没有。</p><ol><li>同步流密码：密钥流产生算法和明文（密文）无关</li><li>自同步流密码：密钥流产生算法与明文（密文）有关</li></ol><h4 id="n级反馈移位寄存器"><a class="headerlink" href="#n级反馈移位寄存器"></a>n级反馈移位寄存器</h4><p>GF（2）上一个n级反馈移位寄存器有n个二元存储器与一个反馈函数f（a1，a2，…，an）组成<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921238.png" alt loading="lazy"></p><h4 id="线性反馈移位寄存器（LFSR）"><a class="headerlink" href="#线性反馈移位寄存器（LFSR）"></a>线性反馈移位寄存器（LFSR）</h4><p>GF(2)上的n级线性反馈移位寄存器，f(a1,a2,…,an)= cna1⊕cn−1a2⊕L⊕c1an<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921239.png" alt loading="lazy"></p><p>n级LFSR状态数：最多有2^n个<br>n级LFSR的状态周期：&lt;=2^n-1。输出序列的周期=状态周期。<br>周期达到最大值的序列称为m序列<br>LFSR的特征多项式：p(x)=1+c1x+…＋cn-1xn-1＋cnxn<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921240.png" alt loading="lazy"></p><h4 id="m序列"><a class="headerlink" href="#m序列"></a>m序列</h4><p>伪随机序列：密钥流不可能完全做到随机性，只能要求截获比周期短的一段序列时不会泄露更多的信息<br>游程：连续的0或1的个数</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921241.png" alt loading="lazy"></p><p>三个有关伪随机序列的随机性公设：</p><p>1.在一个周期内，0和1的个数相差最多为1<br>2.在序列某个周期内，长为1的游程占游程数的1/2，长为2<br>的游程占游程总数的1/2^2，长为i的游程占游程总数的1/2^i,且0和1的游程数相等.<br>3.异相自相关函数为一个常数。<br>m序列满足如上的三个随机性公设。</p><p>对于m序列，游程总数为2^(n-1)。</p><p>GF(2)上周期为 T 的序列{ai }的自相关函数</p><p>设序列{ai}满足线性递推关系：<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921242.png" alt loading="lazy"></p><h4 id="m序列的破译"><a class="headerlink" href="#m序列的破译"></a>m序列的破译</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921243.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921244.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921245.png" alt loading="lazy"></p><h3 id="第三章-分组密码"><a class="headerlink" href="#第三章-分组密码"></a>第三章 分组密码</h3><h4 id="基本概念和分类-2"><a class="headerlink" href="#基本概念和分类-2"></a>基本概念和分类</h4><p>分组密码：若明文流被分割成等长串，各串用相同的加密算法和相同的密钥进行加密，就是分组密码。</p><p>优缺点：<br>分度密码加解密算法简洁快速，所占的计算资源小，易于软件和硬件实现。<br>参数固定，比流密码更易实现标准化。<br>由于明文流被分段加密，因此容易实现同步，且传输错误不会向后扩散。但是分组密码的安全性很难被证明，至多证明局部安全性。</p><h4 id="分组密码的设计准则"><a class="headerlink" href="#分组密码的设计准则"></a>分组密码的设计准则</h4><p>安全性：从任何角度难以攻破<br>简洁性：分组密码吗算法在满足安全性的同时尽可能简单快速。<br>有效性：分组密码设计应使密钥最大限度起到安全性作用。</p><p>透明性和灵活性：透明性即要求算法是可证明安全的，灵活性即要求算法的实现可以适应多种计算环境；明文分组长度可以伸缩；算法可以移植和变形。</p><p>加解密相似性：加密算法和解密算法相同仅仅 密钥的编排不同。这里举的两个例子，异或和模 2n 加</p><h4 id="分组密码的设计"><a class="headerlink" href="#分组密码的设计"></a>分组密码的设计</h4><h5 id="Feistel网络"><a class="headerlink" href="#Feistel网络"></a>Feistel网络</h5><p>Feistel 网络不能用作分组密码算法。Feistel 网络的基本模块是 F-函数。</p><p>F-函数：一个依赖于密钥的把输入串映射到输出串的映射，通常是非线性且不可逆的</p><h6 id="加密"><a class="headerlink" href="#加密"></a>加密</h6><p>(1)将明文分组分割成长度相同的两块（L0,R0);</p><p>(2)对每一轮，i=0,1,…,n,</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921246.png" alt loading="lazy"></p><h6 id="解密"><a class="headerlink" href="#解密"></a>解密</h6><p>（1）对于密文的解密，每一轮，i=n,n-1,…,0,<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921247.png" alt loading="lazy"></p><h5 id="S-盒：输入-输出长度比较小的，用输入-输出真值表来-计算的，仅仅实现高度非线性功能的计算部件称为-S-盒"><a class="headerlink" href="#S-盒：输入-输出长度比较小的，用输入-输出真值表来-计算的，仅仅实现高度非线性功能的计算部件称为-S-盒"></a>S 盒：输入/输出长度比较小的，用输入/输出真值表来 计算的，仅仅实现高度非线性功能的计算部件称为 S 盒</h5><h5 id="DES"><a class="headerlink" href="#DES"></a>DES</h5><h6 id="基本结构"><a class="headerlink" href="#基本结构"></a>基本结构</h6><p>DES 是一个 对称密码体制。 加解密使用同一密钥，有效密钥长度为56位。分组长度为64位。明文和密文长度相等。<br>DES的初始密钥长度也为64位，但有效的密钥为56位，因为第8、16、24、40、48、56和64位都是奇校验位。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921248.jpeg" alt loading="lazy"></p><p>加密过程主要有3个阶段</p><ol><li>64位的明文经过初始置换而被重新排列，并将其分为左右两组L0和 R0，各为32位。</li><li>在密钥参与下，左右两个分组进行16轮相同论函数的迭代，每轮迭代有置换和代换。（最后一轮迭代的输出为64位，左半和右半不进行交换）</li><li>然后通过逆初始置换产生64位密文。</li></ol><p>DES加密算法有四个步骤：初始置换、生成子密钥、迭代过程、逆置换。核心的部件包括初始置换和F函数（E扩展置换，S盒压缩代换，P盒置换运算）以及逆置换</p><h6 id="初始置换和逆初始置换"><a class="headerlink" href="#初始置换和逆初始置换"></a>初始置换和逆初始置换</h6><p>初始置换（IP）是在第一轮迭代之前进行的，目的是将原明文块的位进行换位，其置换表是固定的。</p><p>逆初始置换（IP−1）是初始置换的逆置换，数据块经过初始置换和逆初始置换后恢复到原来的位置</p><h6 id="轮结构"><a class="headerlink" href="#轮结构"></a>轮结构</h6><p>DES的轮函数F由四个部分组成：扩展置换、异或运算、s盒运算、p盒运算。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921249.png" alt loading="lazy"></p><h6 id="密钥生成"><a class="headerlink" href="#密钥生成"></a>密钥生成</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604204618.png" alt loading="lazy"></p><h6 id="DES的安全性"><a class="headerlink" href="#DES的安全性"></a>DES的安全性</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604204710.png" alt loading="lazy"><br>DES存在弱密钥和半弱密钥。所谓弱密钥指的是在同一密钥下加密两次为恒等变换，DES存在4个弱密钥<br>&lt;!–code￼0–&gt;</p><h4 id="五个工作模式"><a class="headerlink" href="#五个工作模式"></a>五个工作模式</h4><h5 id="ECB模式（电码本模式）"><a class="headerlink" href="#ECB模式（电码本模式）"></a>ECB模式（电码本模式）</h5><p>每个明文分组独立加解密<br>优点：</p><p>简单、高速</p><p>无差错传播：单个密文分组出现错误只会影响该分组的解密，不会影响到其他分组</p><p>缺点：</p><p>（1） 相同明文分组对应相同密文分组</p><p>（2） 不能隐蔽明文分组的统计规律和结构规律,不能抵抗替换攻击应用：<br>用法：</p><p>（1） 用于随机数的加密保护</p><p>（2） 用于单分组明文的加密</p><h5 id="CBC模式（密码分组链接模式）"><a class="headerlink" href="#CBC模式（密码分组链接模式）"></a>CBC模式（密码分组链接模式）</h5><p>每个明文分组先于前一密文分组异或，再进行加密<br>明文块的统计特性得到了隐蔽</p><p>有限差错传播：单个密文分组出现错误会影响该分组和后面一个密文分组的解密具有自同步功能</p><h5 id="CFB模式（密码反馈模式）"><a class="headerlink" href="#CFB模式（密码反馈模式）"></a>CFB模式（密码反馈模式）</h5><p>加密消息需按字符、字节或比特处理时，可采用CFB模式<br>实现简单（只要求加密算法）</p><p>比 CBC 慢很多，每次只有少数比特完成加密</p><p>单个密文分组出现一个比特错误，不仅影响该分组，还会最多影响后续[64/j] 个密文分组的解密<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604204220.png" alt loading="lazy"></p><h5 id="OFB模式（输出反馈模式）"><a class="headerlink" href="#OFB模式（输出反馈模式）"></a>OFB模式（输出反馈模式）</h5><p>OFB模式是将加密算法的输出反馈到移位寄存器，cfb则是将密文单元反馈到移位寄存器。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604204233.png" alt loading="lazy"><br>优点</p><p>隐藏了明文的模式；分组密码转化为流模式；无误差传送问题；可以及时加密传送小于分组的数据。</p><p>缺点</p><p>不利于并行计算；对明文的主动攻击是可能的，安全性较CFB差。</p><h5 id="CTR模式"><a class="headerlink" href="#CTR模式"></a>CTR模式</h5><pre><code>每个明文分组都与一个加密技术器相异或。对每个后续分组计数器递增</code></pre><h5 id="三重-DES"><a class="headerlink" href="#三重-DES"></a>三重 DES</h5><p>三重 DES：  先加密后解密在加密<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604204430.png" alt loading="lazy"></p><h4 id="AES加密"><a class="headerlink" href="#AES加密"></a>AES加密</h4><p>明文长度为固定的128位，密钥长度可以是128位、192位、256位<br>输入128位明文，为16字节的数据，16字节的数据组成一个4*4的矩阵</p><h5 id="加密过程"><a class="headerlink" href="#加密过程"></a>加密过程</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921251.png" alt loading="lazy"><br>其中9轮循环运算时，执行1-4步骤，最后一轮（第十轮)只执行124步</p><h6 id="初始变换"><a class="headerlink" href="#初始变换"></a>初始变换</h6><p>16字节固定长度的明文和M字节的密钥分别形成4*4的矩阵，执行异或操作</p><h6 id="循环运算"><a class="headerlink" href="#循环运算"></a>循环运算</h6><ol><li>字节代换：处理初始变换后的4*4矩阵</li><li>行移位：第一行不变，第二三四行行分别向左移动1、2、3个字节</li><li>列混合：将输入的4* 4 矩阵左乘一个给定的4*4矩阵</li><li>轮密钥加：将前面所得的4*4矩阵与该轮对应的轮密钥进行异或操作<br>经过9轮循环和一个最终轮，得到了最终的密文</li></ol><h4 id="IDEA"><a class="headerlink" href="#IDEA"></a>IDEA</h4><p>明文分组是64位，密钥为128位。<br>明文块分组：输入的64位数据块被分为4个16位分组：x1，x2，x3，x4，这4个分组成为算法的8轮计算第一轮的输入。在每一轮中，这4个分组互相异或，相加，相乘，且与6个16位子密钥相异或，相加，相乘。轮与轮间，第二和第三个分组交换，最后在输出变换中4个子分组与4个子密钥进行运算。</p><h5 id="子密钥的生成"><a class="headerlink" href="#子密钥的生成"></a>子密钥的生成</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604202659.png" alt loading="lazy"><br>8轮迭代操作，每轮需要6个子密钥，另外还需要4个额外子密钥用于输出变换，所以共需要52个子密钥，这个52子密钥都是从 128位密钥中扩展出来的。</p><p>首先把输入的Key分成8个16位的子密钥， 1-6 号子密钥供第一轮加密使用，7-8号子密钥供第二轮使用；然后把这个128位密钥循环左移25位，这样Key = k26k27k28…k24k25，把新生成的Key在分成8个16位的子密钥，1-4号子密钥供第二轮加密使用(前面已经提供了两个)5-8号子密钥在第三轮加密使用；到此我们已经得到了16个子密钥，如此继续，当循环左移了5次之后已经生成了48个子密钥,还有四个额外的子密钥需要生成，再次把Key循环左移25位,选取划分出来的8个16位子密钥的前4个作为那4个额外的加密密钥，至此，加密使用的52个子密钥生成完毕。</p><h5 id="加解密"><a class="headerlink" href="#加解密"></a>加解密</h5><h6 id="加密-2"><a class="headerlink" href="#加密-2"></a>加密</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604203026.png" alt loading="lazy"></p><ol><li><p>8轮迭代操作（每轮6个子密钥-&gt;K1-K6、… 、K43-K48）<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604203105.png" alt loading="lazy"></p></li><li><p>输出变换（4个子密钥-&gt;K49~K52）<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604203159.png" alt loading="lazy"></p></li></ol><h6 id="解密-2"><a class="headerlink" href="#解密-2"></a>解密</h6><pre><code>   解密过程与加密过程完全相同，只是子密钥的生成与模式有所不同。解密子密钥实际上是加密子密钥的逆。</code></pre><h5 id="IDEA相关"><a class="headerlink" href="#IDEA相关"></a>IDEA相关</h5><p>安全性：暴力破译IDEA，需要进行2＾128次加密运算，即使取得正确的密钥只要平均搜索一半的密钥空间，依旧很难破解IDEA。同时，设计者尽最大努力使该算法不受差分密码分析的影响，数学家已证明IDEA算法在其8圈迭代的第4圈之后便不受差分密码分析的影响了，目前来看，比DES算法要相对安全得多；</p><p>分组密码：明文分组64位；<br>对称密码算法：密钥长度为128位；<br>优点：IDEA算法比RSA算法加、解密速度快得多；<br>缺点：解密过程子密钥需要求逆且有些微小差别。</p><h4 id="SM4"><a class="headerlink" href="#SM4"></a>SM4</h4><p>分组长度为128比特，密钥长度为128比特，字长度为32比特的字符串，因此分组和密钥长度为4字</p><h5 id="32轮迭代"><a class="headerlink" href="#32轮迭代"></a>32轮迭代</h5><p>已知明文输入X0、X1、X2、X3，依次计算出X4-X35的字（32轮运算）<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921252.png" alt loading="lazy"></p><h5 id="反序变换"><a class="headerlink" href="#反序变换"></a>反序变换</h5><p>将计算出的结果X32-X35倒序</p><h3 id="第四章-公钥密码"><a class="headerlink" href="#第四章-公钥密码"></a>第四章 公钥密码</h3><h4 id="公钥体制的基本原理是陷门单向函数"><a class="headerlink" href="#公钥体制的基本原理是陷门单向函数"></a>公钥体制的基本原理是陷门单向函数</h4><p>陷门单向函数和单向函数不一样是这样的单向函数：在不知陷门信息下，由 f(x)求 x“极为困难” ， 当知道陷门信息后，由 f(x)求 x 是易于实现的<br>单向函数举例：（各自对应一种加密方法）</p><p>离散对数<br>大整数分解<br>背包问题</p><h4 id="RSA"><a class="headerlink" href="#RSA"></a>RSA</h4><p>第一步：选择两个大素数 p 和 q</p><p>第二步：计算 p 和 q 的乘积 n（n 转化成二进制一般是 1024 位，重要的话 2048位）</p><p>第三步：计算 n 的欧拉函数φ(n)=（p-1）*（q-1）</p><p>第四步：随机选整数e，1&lt; e &lt; φ(n)，且 e 与φ(n)互质，计算 e 对于φ(n)的乘法逆元 d</p><p>ed ≡ 1 (mod φ(n))</p><p>第五步：将 n 和 e 封装成公钥，n 和 d 封装成私钥</p><p>※加密：c≡ m^e mod n; c 为密文，且 0&lt;=c&lt;n</p><p>※解密：对于密文 0&lt;=c&lt;n，解密算法为：m≡ c^d mod n;</p><h5 id="RSA-的安全性分析"><a class="headerlink" href="#RSA-的安全性分析"></a>RSA 的安全性分析</h5><p>2511&lt;p&lt;2512</p><p>这样要穷举 2510 次，似乎足够安全</p><h4 id="背包密码"><a class="headerlink" href="#背包密码"></a>背包密码</h4><h4 id="Rabin密码"><a class="headerlink" href="#Rabin密码"></a>Rabin密码</h4><p>第一步：选择两个大素数 p 和 q，要求 p 和 q 都是 4 的倍数加上 3</p><p>第二步：n=p*q</p><p>第三步：公钥 n，对外公布；私钥（p,q）则自己收着。</p><p>Rabin 加密体制加密过程：</p><p>明文 m 范围(0,n)计算密文方法：c=m^2(mod n)，c 是密文 B 在收到密文后，用私钥解密<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921253.png" alt loading="lazy"></p><h5 id="解密-3"><a class="headerlink" href="#解密-3"></a>解密</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921254.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921255.png" alt loading="lazy"></p><h4 id="ECC"><a class="headerlink" href="#ECC"></a>ECC</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921256.png" alt loading="lazy"></p><h5 id="椭圆曲线上的点数"><a class="headerlink" href="#椭圆曲线上的点数"></a>椭圆曲线上的点数</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921257.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921258.png" alt loading="lazy"></p><h5 id="加法运算"><a class="headerlink" href="#加法运算"></a>加法运算</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921259.png" alt loading="lazy"></p><h5 id="加密过程-2"><a class="headerlink" href="#加密过程-2"></a>加密过程</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921260.png" alt loading="lazy"></p><h4 id="ElGamal"><a class="headerlink" href="#ElGamal"></a>ElGamal</h4><p>密钥产生过程： 选择一素数p以及小于p的随机数x， g是p的原根，计算y≡g^x mod p。</p><h5 id="加密-3"><a class="headerlink" href="#加密-3"></a>加密</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921261.png" alt loading="lazy"></p><h5 id="解密-4"><a class="headerlink" href="#解密-4"></a>解密</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921262.png" alt loading="lazy"></p><h4 id="SM2"><a class="headerlink" href="#SM2"></a>SM2</h4><h3 id="第五章-密钥分配与密钥管理"><a class="headerlink" href="#第五章-密钥分配与密钥管理"></a>第五章 密钥分配与密钥管理</h3><h4 id="Diffie-Hellman-交换"><a class="headerlink" href="#Diffie-Hellman-交换"></a>Diffie-Hellman 交换</h4><p>密钥交换是实现安全通信的基础</p><h5 id="密钥交换的方法"><a class="headerlink" href="#密钥交换的方法"></a>密钥交换的方法</h5><p>基于RSA的密钥交换<br>基于KDC技术<br>Diffie-Hellman密钥交换<br>基于物理层的交换</p><h6 id="DH算法"><a class="headerlink" href="#DH算法"></a>DH算法</h6><p>该算法的唯一目的是使得两个用户能够安全交换密钥，算法本身不能用于加解密。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604170517.png" alt loading="lazy"><br>敌手只能得到p、a、YA、YB，无法得到密钥。</p><h6 id="安全问题"><a class="headerlink" href="#安全问题"></a>安全问题</h6><p>算法的安全性基于求离散对数的困难性。</p><ol><li>容易遭受阻塞攻击<br>因为幂运算是计算密集性的，当敌手发起大量的密钥<br>请求，受攻击者将花费较大计算资源来做幂运算；</li><li>容易遭受中间人攻击<br>敌手可分别冒充用户A和B中的一方，与另一方交<br>换密钥（敌手就可以监听和传递A和B的秘密信息而不被发现）。</li></ol><h5 id="秘密分割"><a class="headerlink" href="#秘密分割"></a>秘密分割</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604171254.png" alt loading="lazy"></p><h6 id="Shamir门限方案"><a class="headerlink" href="#Shamir门限方案"></a>Shamir门限方案</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604171602.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604171628.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604171654.png" alt loading="lazy"></p><h6 id="基于中国剩余定理的门限方案"><a class="headerlink" href="#基于中国剩余定理的门限方案"></a>基于中国剩余定理的门限方案</h6><p>分解秘密<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604173918.png" alt loading="lazy"><br>恢复秘密<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604173954.png" alt loading="lazy"></p><h3 id="第六章-消息认证和哈希函数"><a class="headerlink" href="#第六章-消息认证和哈希函数"></a>第六章 消息认证和哈希函数</h3><h4 id="消息认证"><a class="headerlink" href="#消息认证"></a>消息认证</h4><p>信息安全一方面要实现消息的保密传送，可抵抗被动攻击，如窃听攻击等；另一方面还要防止攻击者对系统的主动攻击，如伪造或纂改消息。<br>认证是对抗主动攻击的主要方法，分为实体认证，和消息认证。<br>实体认证：验证实体的身份<br>消息认证：验证消息的真实性<br>验证消息来源的真实性，称之为信息源认证。<br>验证消息的完整性，即验证消息在传输和存储过程中没有被纂改、伪造。</p><p>消息认证的基础是生成消息认证码(MAC，Message Authentication Code)，用来检查消息是否被恶意修改。</p><p>认证码与通信学中的检错码不同:</p><p>检错码是用来检测由于通信的缺陷而导致消息发生错误的特殊代码<br>认证码是用来防止攻击者恶意篡改或伪造消息<br>消息认证码利用消息和双方共享的密钥通过认证函数来生成一个固定长度的短数据块，并将该数据块附加在消息后。</p><h4 id="HMAC"><a class="headerlink" href="#HMAC"></a>HMAC</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604213351.png" alt loading="lazy"></p><p>K表示密钥，密钥长度可以是任意长度,最小推荐长度nbit，因为小于nbit会显著降低函数的安全性，大nbit也不会增加安全性<br>M 表示HMAC的消息输入<br>L 表示消息M中的分组数<br>Yi 表示消息M的第i 个分组<br>b 表示每个分组包含的比特数<br>n 表示嵌入的散列函数产生的散列码长度<br>IV 表示初始链接变量<br>ipad表示字节0x36重复 b/8次后的结果<br>opad表示字节0x5C重复 b/8次后的结果<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604213606.png" alt loading="lazy"><br>操作流程：<br>（1）密钥K 的左边填充0 ，以产生一个b 比特长<br>(例如K 的长为160 比特，b = 512 ，则需填充44 个零字节0x00)。<br>（2）K+ 与ipad逐比特异或产生b比特的分组Si<br>（3）将消息M 附加到Si 后<br>（4）将Hash函数H 作用于步骤（3）的结果，生成消息摘要<br>（5）K+ 与opad逐比特异或产生b比特的分组S0<br>（6）将步骤(4)生成的消息摘要链接在S0 后<br>（7）将Hash函数H 作用于步骤(6)的结果，生成消息摘要，并输出最终结果<br>实现HMAC的有效方式：<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604213703.png" alt loading="lazy"></p><h4 id="哈希函数"><a class="headerlink" href="#哈希函数"></a>哈希函数</h4><h5 id="概念"><a class="headerlink" href="#概念"></a>概念</h5><p>Hash 函数也称散列函数、杂凑函数，是一个从消息空间到像空间的不可逆映射。hash函数能将任意长度的消息经过hash变换为固定长度的像。所以是一种具有压缩性质的单向函数。通常称其为数字指纹、消息摘要或散列值。<br>散列值的生成过程为： h=H(M)<br>H可用于任意长度的消息。<br>H产生定长的输出<br>对任意消息x,计算H(x)很容易，易于软硬件实现。<br>单向性：又称抗原像性，即给定任意H(x)，要找出x在计算上是不可行的。<br>抗强碰撞性：找到任意满足H(x)=H(y)的偶对x=y,在计算上是不可行的<br>抗弱碰撞性：又称抗第二原像性，给定任意消息x ,找到满足y!=x且H(y)=H(x)的消息在计算上是不可行的。</p><h5 id="函数结构"><a class="headerlink" href="#函数结构"></a>函数结构</h5><p>MD结构：将输入的消息分为L个固定长度的的分组，每组长度为b位，若最后一个分组长度不为b位则需要填充。<br>迭代结构包含一个压缩函数f。函数f有两个输入，一个是前一次迭代的n为输出，一个是消息的b位分组，并产生一个n位的输出。因为一般情况来说消息分组长度b大于输出长度n，所以称为压缩函数<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604111951.png" alt loading="lazy"></p><h5 id="生日攻击"><a class="headerlink" href="#生日攻击"></a>生日攻击</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240605205618.png" alt loading="lazy"><br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240605205635.png" alt loading="lazy"><br>从而当k=100时，这100人中至少有两人生日相同近乎必然事件，然而这个结果似乎不合实际。这就是生日悖论。<br>要找到一个与特定非消息具有相同的散列值的另一个消息的改路很小。如果不指定散列值，只是在两组消息中找到具有相同散列值的两个消息，问题就容易很多。<br>所以攻击者就会利用hash空间不够大易制造碰撞来进行攻击。<br>生日攻击告诉我们：为了能达到 n-bit 的安全性，你所选择的 Hash 函数的散列值长度应该是 2n。</p><p>第一类生日攻击（课本定义）：已知一个哈希函数有n个可能的输出，随机取k个输入，至少有一个输入y使得H(y)=H(x)的概率为0.5时，k=n/2<br>特别地，如果H的输出为m比特长，即可能的输出个数n=2m，则k=n/2=2^(m-1)</p><p>第二类生日攻击（课本定义）：Hash函数有2^m个可能输出，如果k个输入至少有两个产生相同输出的概率大于0.5，则k≈2^(m/2)</p><h5 id="MD5哈希算法"><a class="headerlink" href="#MD5哈希算法"></a>MD5哈希算法</h5><h6 id="描述"><a class="headerlink" href="#描述"></a>描述</h6><p>输入长度小于2^64字节的消息，输出长度为128位的消息摘要，输入的消息以512比特分组位单位处理。</p><h6 id="算法流程"><a class="headerlink" href="#算法流程"></a>算法流程</h6><p>1.对消息填充。 使其比特长在模512下位448<br>，留出64比特。<br>填充方式是固定的：第一位为1，其后各位皆为0.<br>2.附加消息的长度。用留出的64比特，以小端的方式来表示消息被填充前的长度。如果消息大于2^64， 就以2^64为模数取余。<br>前两步执行完以后，分组长为512的分组又可以表示为16个32比特长的字<br>3.对MD缓冲区初始化。算法采用128比特长的缓冲区以存储中间结果和最终哈希值。MD5使用四个32位的寄存器A、B、C、D。最开始存放4个固定的32位参数，即初始链接变量。<br>4.以分组为单位对消息进行处理。迭代压缩处理。<br>5.输出哈希值。将最后一个Hmd5的输出即为产生的消息摘要。（第四轮完成后，做如下运算：A=（A+AA）mod 232,B=（B+BB）mod 232,C=（C+CC）mod 232,D=（D+DD）mod 232.最后将四个寄存器的值做下一次迭代压缩时 的输入变量，知道最后一个消息分组输出128位的散列值。）</p><h6 id="压缩函数"><a class="headerlink" href="#压缩函数"></a>压缩函数</h6><p>Hmd5压缩函数有4轮处理过程，每轮对缓冲区ABCD进行16步迭代运算。<br>MD5的步函数，即压缩函数，先取向量( A , B , C , D ) 中的后3个作一次非线性函数运算，然后将所得的结果依次加上第1个变量、M [ j ] 、T[i]，再将所得结果循环左移s 位，并加上( A , B , C , D ) 中的第2个变量B ，最后把新值赋给向量中的第1个变量。</p><p>详细过程如下所示，其中 M[j]为消息分组M的第j （ 0 ≤ j ≤ 15 ）个32bit子分组</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406041614319.png" alt loading="lazy"></p><ol><li>T[i]指的是常数表T中的第i个字，+为模2^32的加法.</li><li>循环左移 。 &lt;&lt;&lt; s 表示循环左移s位。</li><li>非线性函数。4轮使用四个不同的函数，每轮16步采用同一函数。<br>其中，x 、 y 和 z x、y和zx、y和z是3个32bit的输入变量，输出是一个32bit变量；∧ 、 ∧ 、 ¬ 、 ⊕ \分别表示与、或、非和异或逻辑运算。</li></ol><h5 id="SHA-1"><a class="headerlink" href="#SHA-1"></a>SHA-1</h5><p>算法的输入：小于2^64比特长的任意消息，分为512比特长的分组。</p><p>算法的输出：160比特长的消息摘要。</p><h6 id="算法步骤"><a class="headerlink" href="#算法步骤"></a>算法步骤</h6><ol><li>对消息填充，让长度满足：<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604205025.png" alt loading="lazy"><br>消息的长度为24位，64位留下作为表示消息的长度，那么512-64-24=424，因此424位就补位64位，表示消息长度，因此消息长度的最大值不能超过2^64</li><li>分组处理（迭代压缩）。<br>对消息进行分组，每组64位，一共有16组。<br>SHA1以512位的分组为单位处理消息，算法核心是一个包含4个循环的模块，每个环由20个步骤组成，每个循环使用的步函数相同，不同的循环中步函数包含不同的非线性函数(Ch、Parity、Maj、Parity)。</li></ol><p>每一步函数的输入也不相同，除了寄存器A 、 B 、 C 、 D 和E 外，还有额外常数K 、与消息分组相关的W[t]，其中t ( 0 ≤ t ≤ 79 ) 为步数。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604205517.png" alt loading="lazy"></p><h6 id="压缩函数-2"><a class="headerlink" href="#压缩函数-2"></a>压缩函数</h6><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604205554.png" alt loading="lazy"><br>1.常数Kt<br>K的4 个取值分别为2 、 3 和10 的平方根，然后再乘以2^{30}=1073741824，最后取结果整数部分的十六进制。<br>2. 循环左移<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604210343.png" alt loading="lazy"><br>3. 生成字<br>32bit的字Wt从512bit消息分组中导出，在前16步处理中Wt值等于消息分组中的相应字</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604210910.png" alt loading="lazy"></p><p>与MD5比较，MD5直接中一个消息分组的16个字作为每步迭代的输入，而SHA-1则是将输入分组的16个字扩展成80各自以供压缩函数使用，从而使得寻找具有相同的压缩值的不同消息分组更为困难。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240604211222.png" alt loading="lazy"></p><h5 id="SHA-与MD5的比较"><a class="headerlink" href="#SHA-与MD5的比较"></a>SHA 与MD5的比较</h5><ol><li>抗穷搜索攻击的强度：<br>SHA 和MD5 的消息摘要长度位160和128，而要用穷搜索攻击找出具有相同消息摘要的不同消息需做2^80与2^64次运算。SHA的抗穷搜索攻击的强度更高。</li><li>抗击密码分析的强度：<br>SHA设计准则未被公开，应该更高。</li><li>速度：<br>都是模2^32的加法运算，但是，SHA迭代步数更高 ，所用缓冲区更大，所以相同硬件下SHA更慢。</li><li>数据的存储方式：<br>MD5采用小端方式，SHA采用大端方式。</li><li>简洁与紧致性：<br>都挺简单的。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Education </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>solidity</title>
      <link href="/2024/05/28/solidity/"/>
      <url>/2024/05/28/solidity/</url>
      
        <content type="html"><![CDATA[<h3 id="错误处理及异常：Assert-Require-Revert"><a class="headerlink" href="#错误处理及异常：Assert-Require-Revert"></a>错误处理及异常：Assert, Require, Revert</h3><h4 id="用-assert-检查异常-Panic-和-require-检查错误-Error"><a class="headerlink" href="#用-assert-检查异常-Panic-和-require-检查错误-Error"></a>用 assert 检查异常(Panic) 和 require 检查错误(Error)</h4><p>assert和require可用于检查条件并抛出异常<br>assert函数会创建一个Painc（uint256）的错误，只用于测试内部错误，检查不变量。<br>下列情况将会产生一个Panic异常： 错误数据会提供的错误码编号，用来指示Panic的类型：</p><p>0x00: 用于常规编译器插入的Panic。<br>0x01: 如果你调用 assert 的参数（表达式）结果为 false 。<br>0x11: 在 unchecked { … } 外，如果算术运算结果向上或向下溢出。<br>0x12; 如果你用零当除数做除法或模运算（例如 5 / 0 或 23 % 0 ）。<br>0x21: 如果你将一个太大的数或负数值转换为一个枚举类型。<br>0x22: 如果你访问一个没有正确编码的存储byte数组.<br>0x31: 如果在空数组上 .pop() 。<br>0x32: 如果你访问 bytesN 数组（或切片）的索引太大或为负数。(例如： x[i] 而 i &gt;= x.length 或 i &lt; 0).<br>0x41: 如果你分配了太多的内内存或创建了太大的数组。<br>0x51: 如果你调用了零初始化内部函数类型变量。</p><p>assert当参数是false时会抛出panic异常，立即停止执行剩余代码，回滚当前交易所有状态变更(即任何更改不会保存在链上)，交易失败所消耗的gas不会返还。</p><p>require函数可以创建无错误提示的错误，也可创建一个 Error(string) 类型的错误。<br>下列情况将会产生一个 Error(string) （或无错误提示）的错误：</p><p>如果你调用 require(x) ，而 x 结果为 false 。<br>如果你使用 revert() 或者 revert(“description”) 。<br>如果你在不包含代码的合约上执行外部函数调用。<br>如果你通过合约接收以太币，而又没有 payable 修饰符的公有函数（包括构造函数和 fallback 函数）。<br>如果你的合约通过公有 getter 函数接收 Ether 。</p><h4 id="revert"><a class="headerlink" href="#revert"></a>revert</h4><p>可以使用revert语句和函数来直接触发回退。<br>revert 语句将一个自定义的错误作为直接参数，没有括号：</p><p>revert CustomError(arg1, arg2);<br>由于向后兼容，还有一个 revert() 函数，它使用圆括号接受一个字符串：</p><p>revert(); revert(“description”);</p><h3 id="合约"><a class="headerlink" href="#合约"></a>合约</h3><h4 id="函数修改器"><a class="headerlink" href="#函数修改器"></a>函数修改器</h4><p>它们可以在执行函数之前自动检查某个条件。 修改器modifier 是合约的可继承属性，并可能被派生合约覆盖 , 但前提是它们被标记为 virtual.。<br>&lt;!–code￼0–&gt;<br>上述例子中，我们通过关键字 modifier 后面接函数修改器名 NoteBook 来定义一个modifier。在上述定义的modifier中如果调用者不是拥有者则会停止执行接下来的代码，并在控制台输出自定义的原因。如果是的话则执行到 _ 处，_ 代表使用该modifier的函数体，这里即为changeRecord 函数的函数体。在执行changeRecord 函数前先会使用isOwner进行检查，没有问题后才会执行。<br>&lt;!–code￼1–&gt;<br>如以上代码所示：在 _后又有一句代码a = 100 。函数执行完return后，后面的代码则不再执行，但是在modifier中，执行完函数体 _ 还会接着执行 a = 100 这条语句。所以尽管函数返回的a 的值为10，但是最后a的值变成了100。</p><h4 id="Constant-和-Immutable-状态变量"><a class="headerlink" href="#Constant-和-Immutable-状态变量"></a>Constant 和 Immutable 状态变量</h4><p>对于 constant 常量, 他的值在编译器确定，而对于 immutable(不可变量), 它的值在部署时确定。<br>对于constant状态量，只能使用那些在编译时有确定值的表达式 ，任何通过访问 storage，区块链数据（例如 block.timestamp, address(this).balance 或者 block.number）或执行数据（ msg.value 或 gasleft() ） 或对外部合约的调用来给它们赋值都是不允许的。<br>内建（built-in）函数 keccak256 ， sha256 ， ripemd160 ， ecrecover ， addmod 和 mulmod 是允许的（即使他们确实会调用外部合约， keccak256 除外）。<br>对于immutable，可以在合约的构造函数中或声明时为不可变的变量分配任意值。 不可变量只能赋值一次，并且在赋值之后才可以读取。</p><h4 id="状态可变性"><a class="headerlink" href="#状态可变性"></a>状态可变性</h4><h5 id="view"><a class="headerlink" href="#view"></a>view</h5><p>要求保证不修改状态<br>下面的语句被认为是修改状态：</p><p>修改状态变量。<br>产生事件。<br>创建其它合约。<br>使用 selfdestruct。<br>通过调用发送以太币。<br>调用任何没有标记为 view 或者 pure 的函数。<br>使用低级调用。<br>使用包含特定操作码的内联汇编。</p><h5 id="pure"><a class="headerlink" href="#pure"></a>pure</h5><p>函数可以声明为 pure ，在这种情况下，承诺不读取也不修改状态变量。</p><p>特别是，应该可以在编译时确定一个 pure 函数，它仅处理输入参数和 msg.data ，对当前区块链状态没有任何了解。 这也意味着读取 immutable 变量也不是一个 pure 操作。<br>除了上面解释的状态修改语句列表之外，以下被认为是读取状态：</p><p>读取状态变量。<br>访问 address(this).balance 或者 &lt;address&gt;.balance。<br>访问 block，tx， msg 中任意成员 （除 msg.sig 和 msg.data 之外）。<br>调用任何未标记为 pure 的函数。<br>使用包含某些操作码的内联汇编。</p><h4 id="Event"><a class="headerlink" href="#Event"></a>Event</h4><p>在Solidity 代码中，使用event 关键字来定义一个事件，这个用法和定义函数式一样的，并且事件在合约中同样可以被继承。触发一个事件使用emit(说明，之前的版本里并不需要使用emit)，触发事件可以在任何函数中调用。</p><h4 id="继承"><a class="headerlink" href="#继承"></a>继承</h4><p>父合约标记为 virtual 函数可以在继承合约里重写(overridden)以更改他们的行为。重写的函数需要使用关键字 override 修饰<br>重写函数只能将覆盖函数的可见性从 external 更改为 public 。<br>可变性可以按照以下顺序更改为更严格的一种： nonpayable 可以被 view 和 pure 覆盖。 view 可以被 pure 覆盖。 payable 是一个例外，不能更改为任何其他可变性<br>如果函数没有标记为 virtual ， 那么派生合约将不能更改函数的行为(即不能重写)<br>对于多重继承，如果有多个父合约有相同定义的函数， override 关键字后必须指定所有父合约名。<br>如果（重写的）函数继承自一个公共的父合约， override 是可以不用显示指定的<br>private 的函数是不可以标记为 virtual 的。<br>除接口之外（因为接口会自动作为 virtual ），没有实现的函数必须标记为 virtual<br>从 Solidity 0.8.8 开始, 在重写接口函数时不再要求 override 关键字，除非函数在多个父合约定义。<br>尽管 public 的状态变量可以重写外部函数，但是 public 的状态变量不能被重写。</p><h4 id="代理合约"><a class="headerlink" href="#代理合约"></a>代理合约</h4><p>Solidity合约部署在链上之后，代码是不可变的（immutable）。这样既有优点，也有缺点：</p><p>优点：安全，用户知道会发生什么（大部分时候）。<br>坏处：就算合约中存在bug，也不能修改或升级，只能部署新合约。但是新合约的地址与旧的不一样，且合约的数据也需要花费大量gas进行迁移。<br>有没有办法在合约部署后进行修改或升级呢？答案是有的，那就是代理模式。<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240620163158.png" alt loading="lazy"><br>代理模式将合约数据和逻辑分开，分别保存在不同合约中。我们拿上图中简单的代理合约为例，数据（状态变量）存储在代理合约中，而逻辑（函数）保存在另一个逻辑合约中。代理合约（Proxy）通过delegatecall，将函数调用全权委托给逻辑合约（Implementation）执行，再把最终的结果返回给调用者（Caller）。</p><p>代理模式主要有两个好处：</p><p>可升级：当我们需要升级合约的逻辑时，只需要将代理合约指向新的逻辑合约。<br>省gas：如果多个合约复用一套逻辑，我们只需部署一个逻辑合约，然后再部署多个只保存数据的代理合约，指向逻辑合约。</p><h4 id="发送eth"><a class="headerlink" href="#发送eth"></a>发送eth</h4><ol><li>transfer<br>用法是接收方地址.transfer(发送ETH数额)。<br>transfer()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。<br>transfer()如果转账失败，会自动revert（回滚交易）。<br>代码样例，注意里面的_to填ReceiveETH合约的地址，amount是ETH转账金额：<br>&lt;!–code￼2–&gt;</li><li>send<br>用法是接收方地址.send(发送ETH数额)。<br>send()的gas限制是2300，足够用于转账，但对方合约的fallback()或receive()函数不能实现太复杂的逻辑。<br>send()如果转账失败，不会revert。<br>send()的返回值是bool，代表着转账成功或失败，需要额外代码处理一下。<br>&lt;!–code￼3–&gt;</li><li>call<br>用法是接收方地址.call{value: 发送ETH数额}(“”)。<br>call()没有gas限制，可以支持对方合约fallback()或receive()函数实现复杂逻辑。<br>call()如果转账失败，不会revert。<br>call()的返回值是(bool, data)，其中bool代表着转账成功或失败，需要额外代码处理一下。<br>&lt;!–code￼4–&gt;<br>call没有gas限制，最为灵活，是最提倡的方法；<br>transfer有2300 gas限制，但是发送失败会自动revert交易，是次优选择；<br>send有2300 gas限制，而且发送失败不会自动revert交易，几乎没有人用它。</li></ol><h4 id="try-catch"><a class="headerlink" href="#try-catch"></a>try catch</h4><p>在solidity中，try-catch只能被用于external函数或创建合约时constructor（被视为external函数）的调用。基本语法如下：<br>&lt;!–code￼5–&gt;<br>其中externalContract.f()是某个外部合约的函数调用，try模块在调用成功的情况下运行，而catch模块则在调用失败时运行。</p><p>同样可以使用this.f()来替代externalContract.f()，this.f()也被视作为外部调用，但不可在构造函数中使用，因为此时合约还未创建。</p><p>如果调用的函数有返回值，那么必须在try之后声明returns(returnType val)，并且在try模块中可以使用返回的变量；如果是创建合约，那么返回值是新创建的合约变量。</p><h3 id="代币水龙头"><a class="headerlink" href="#代币水龙头"></a>代币水龙头</h3><p>我们实现一个简版的ERC20水龙头，逻辑非常简单：我们将一些ERC20代币转到水龙头合约里，用户可以通过合约的requestToken()函数来领取100单位的代币，每个地址只能领一次。<br>&lt;!–code￼6–&gt;<br>首先，部署ERC20代币合约，名称和符号为WTF，并给自己mint 10000 单位代币。<br>部署Faucet水龙头合约，初始化的参数填上面ERC20代币的合约地址。<br>利用ERC20代币合约的transfer()函数，将 10000 单位代币转账到Faucet合约地址。<br>换一个新账户，调用Faucet合约requestTokens()函数，领取代币。可以在终端看到SendToken事件被释放。<br>在ERC20代币合约上利用balanceOf查询领取水龙头的账户余额，可以看到余额变为100，领取成功！</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>ciscn 2024</title>
      <link href="/2024/05/27/ciscn-2024/"/>
      <url>/2024/05/27/ciscn-2024/</url>
      
        <content type="html"><![CDATA[<h3 id="火锅链观光打卡"><a class="headerlink" href="#火锅链观光打卡"></a>火锅链观光打卡</h3><p>签到题</p><h3 id="Power-Trajectory-Diagram"><a class="headerlink" href="#Power-Trajectory-Diagram"></a>Power Trajectory Diagram</h3><p>下载得到attachment.npz文件，发现有四部分数据，通过查看 input 和 index 后可以知道<br>题目是一共爆破了13个字符，每个字符爆破了40次，然后每次爆破都会有一条 trace<br>写一个 python 脚本读取 trace 数据并画折线图，发现每条 trace 都会有一个最小值</p><p>&lt;!–code￼0–&gt;</p><h3 id="神秘文件"><a class="headerlink" href="#神秘文件"></a>神秘文件</h3><p>太难找了<br>part3 运用了宏编辑<br>alt+f11打开宏编辑页面</p><p>然后 base64 的RC4 解码 然后base64<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925897.png" alt loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925898.png" alt loading="lazy"></p><h3 id="通风机"><a class="headerlink" href="#通风机"></a>通风机</h3><p>STEP7 MicroWIN V4.0 SP9 软件打开然后在 symbol table 中发现 base64 编码后的 flag，CyberChef 解码即可得到 flag</p><h3 id="Tough-DNS"><a class="headerlink" href="#Tough-DNS"></a>Tough_DNS</h3><p>题目内容：DNS的世界充满了多变的字符，接下来我将直接给你答案：56 16 26 93 66 53 16 56 d2 03 26 93 56<br>题目给了一个DNS流量包，发现有的包中有二进制数据，导出<br>&lt;!–code￼1–&gt;<br>然后将其转为二维码<br>&lt;!–code￼2–&gt;<br>扫码得到<br>15f9792dba5c<br>明显不是flag，继续看流量包，发现txt解析记录将其提取出来</p><p>&lt;!–code￼3–&gt;<br>得到两个文件，2.条txt文件发现是一个zip，那么猜测二维码扫出来的是密码。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925899.png" alt loading="lazy"></p><p>得到secret.gpg<br>&lt;!–code￼4–&gt;<br>可以看出是一个pgp加密的公钥，那另一个是密文了，将其转为16进制导出。</p><p>然后题目给的是私钥了：56 16 26 93 66 53 16 56 d2 03 26 93 56<br>将其反转并转ascii</p><p>&lt;!–code￼5–&gt;<br>然后进行解码即可得到flag<br>&lt;!–code￼6–&gt;<br>&lt;!–code￼7–&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925900.png" alt loading="lazy"></p><h3 id="盗版软件"><a class="headerlink" href="#盗版软件"></a>盗版软件</h3><p>得到一个exe文件和一个dmp文件，运行exe文件后得到一张图片，发现其上方有点<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925901.png" alt loading="lazy"><br>在全红是可以看出有zip，但是中间有垃圾数据，提取</p><p>&lt;!–code￼8–&gt;<br>得到一个.b文件，进行base85解码<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925902.png" alt loading="lazy"><br>然后在云沙箱运行<br><a href="https://s.threatbook.com/report/file/a97946c34d2d8642820f196a54a6e8d78cf4f58a97e417be9696d7fd19e7fc95">https://s.threatbook.com/report/file/a97946c34d2d8642820f196a54a6e8d78cf4f58a97e417be9696d7fd19e7fc95</a></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925903.png" alt loading="lazy"><br>得到 IP : 39.100.72.235<br>但是dmp用vol提取不出来东西，使用010，utf-8编码<br><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925904.png" alt loading="lazy"><br>得到 <a href="http://winhack.com">winhack.com</a></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>出题记录</title>
      <link href="/2024/05/15/%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95/"/>
      <url>/2024/05/15/%E5%87%BA%E9%A2%98%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h3 id="ez"><a class="headerlink" href="#ez"></a>ez</h3><p>据曾经做过的一个题目，需要python像素旋转。</p><p>使用PIL库对图片每一行像素进行循环移位：备份每一行的像素值，计算一个随机的起始点，然后对这一行的像素进行循环移位，最后保存并显示处理后的图像。通过这种方式，图像的每一行都会有一个随机的循环移位效果。</p><p>&lt;!–code￼0–&gt;</p><p>由<img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030920129.png" alt loading="lazy"></p><p>得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030920130.png" alt loading="lazy"></p><h4 id="wp："><a class="headerlink" href="#wp："></a>wp：</h4><p>&lt;!–code￼1–&gt;</p><h3 id="lsb隐写"><a class="headerlink" href="#lsb隐写"></a>lsb隐写</h3><p>&lt;!–code￼2–&gt;</p><h3 id="网站"><a class="headerlink" href="#网站"></a>网站</h3><p><a href="https://incoherency.co.uk/image-steganography/">图像隐写术 (incoherency.co.uk)</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>address计算</title>
      <link href="/2024/04/23/address%E8%AE%A1%E7%AE%97/"/>
      <url>/2024/04/23/address%E8%AE%A1%E7%AE%97/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a class="headerlink" href="#原理"></a>原理</h3><p>以太坊有两种类型的账户：普通账户和合约账户。合约是通过发送带有空字段的事务(空的 to)来创建的，并且包含一些被执行的数据（一个构造函数），并且希望返回一些放在区块链上的代码。 这些合同自然是与正常账户相同的地址空间的一部分; 由此确定合同的地址：</p><p>&lt;!–code￼0–&gt;</p><p>合约地址是确定性的，由 keccack256(address,nonce) 计算。(其中 address 是合约的地址(或创建交易的以太坊地址)，而 nonce 是合约生产其它合约的一个数值(或者对于常规交易来说是交易的nonce))。</p><p>从本质上讲，合约的地址就是账户与交易 nonce 串联的 keccak256 哈希值。合约的 nonce 是以 1 开始的，账户的交易 nonce 是以 0 开始的。</p><p>&lt;!–code￼1–&gt;</p><h3 id="地址计算脚本"><a class="headerlink" href="#地址计算脚本"></a>地址计算脚本</h3><h4 id="python"><a class="headerlink" href="#python"></a>python</h4><p>&lt;!–code￼2–&gt;</p><h4 id="solidity"><a class="headerlink" href="#solidity"></a>solidity</h4><p>&lt;!–code￼3–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 学习</title>
      <link href="/2024/04/15/Python-%E5%AD%A6%E4%B9%A0/"/>
      <url>/2024/04/15/Python-%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h3 id="os"><a class="headerlink" href="#os"></a>os</h3><p>os.getcwd()</p><p>查看当前路径。</p><p>os.listdir(path)</p><p>返回指定目录下包含的文件和目录名列表。</p><p>os.path.abspath(path)</p><p>返回路径 path 的绝对路径。</p><p>os.path.split(path)</p><p>将路径 path 拆分为目录和文件两部分，返回结果为元组类型。</p><p>os.path.join(path, *paths)</p><p>将一个或多个 path（文件或目录） 进行拼接。</p><p>os.path.getctime(path)</p><p>返回 path（文件或目录） 在系统中的创建时间。</p><p>os.path.getmtime(path)</p><p>返回 path（文件或目录）的最后修改时间。</p><p>os.makedirs()</p><p>创建多级目录。</p><h3 id="time"><a class="headerlink" href="#time"></a>time</h3><h4 id="struct-time"><a class="headerlink" href="#struct-time"></a>struct_time</h4><p>代表一个时间对象，可以通过索引以及属性名来访问。</p><p>&lt;!–code￼0–&gt;</p><p>localtime()表示当前时间，返回类型为 struct_time对象</p><h4 id="常用函数"><a class="headerlink" href="#常用函数"></a>常用函数</h4><p>&lt;!–code￼1–&gt;</p><h3 id="多线程"><a class="headerlink" href="#多线程"></a>多线程</h3><p>线程是CPU分配资源的基本单位。当一程序开始运行，这个程序就变成了一个进程，而一个进程相当于一个或者多个线程。当没有多线程编程时，一个进程相当于一个主线程；当有多线程编程时，一个进程包含多个线程（含主线程）。使用线程可以实现程序大的开发。</p><h5 id="创建多线程"><a class="headerlink" href="#创建多线程"></a>创建多线程</h5><ol><li>threading.Thread()创建</li></ol><p>语法形式：</p><p>threading.Thread(group=nore,target=none,args=(),kwargs={},*,daemon=None)</p><p>~group：必须为None，于ThreadGroup类相关，一般不使用。</p><p>~target：线程调用的对象，就是目标函数。</p><p>~name：为线程起这个名字。默认是Tread-x，x是序号，由1开始，第一个创建的线程名字就是Tread-1。</p><p>~args：为目标函数传递关键字参数，字典。</p><p>~daemon：用来设置线程是否随主线程退出而退出。</p><p>&lt;!–code￼2–&gt;</p><p>两个程序是并发运行，所以顺序可能不</p><ol start="2"><li><p>treading.Thread类的继承</p><p>&lt;!–code￼3–&gt;</p></li></ol><h4 id="主线程"><a class="headerlink" href="#主线程"></a>主线程</h4><p>第一个启动的线程就是主线程</p><p>父线程： 启动A线程中启动了线程B，A就是B的父线程</p><p>子线程：B就是A的子线程。</p><p>创建线程时有一个damon属性，用它来判断主线程。当daemon设置False时，线程不会随主线程退出而退出，主线程会一直等着子线程执行完;。当daemon设置True时，线程会随主线程退出而退出，主线程结束其他的子线程会强制退出。</p><h4 id="阻塞线程"><a class="headerlink" href="#阻塞线程"></a>阻塞线程</h4><p>在一个线程中调用另一个线程的join方法，调用者被阻塞，知道调用线程被终止。</p><p>语法形式：</p><p>&lt;!–code￼4–&gt;</p><p>不设置时，就一直等待被调用线程结束。</p><p>&lt;!–code￼5–&gt;</p><p>&lt;!–code￼6–&gt;</p><h4 id="判断主线程是否活动"><a class="headerlink" href="#判断主线程是否活动"></a>判断主线程是否活动</h4><p>run() ：表示线程活动的方法</p><p>start() ：启动线程</p><p>join() ：等待线程终止</p><p>isAlive() ：返回线程是否活动</p><p>getAame() ：返回线程名称</p><p>setName() ：设置线程名称</p><h4 id="线程同步"><a class="headerlink" href="#线程同步"></a>线程同步</h4><h5 id="python的锁就解决这一问题，锁住线程，只允许一个线程操作，其他线程排队等待，待当前线程操作完毕后，再按顺序一个一个来运行。"><a class="headerlink" href="#python的锁就解决这一问题，锁住线程，只允许一个线程操作，其他线程排队等待，待当前线程操作完毕后，再按顺序一个一个来运行。"></a>python的锁就解决这一问题，锁住线程，只允许一个线程操作，其他线程排队等待，待当前线程操作完毕后，再按顺序一个一个来运行。</h5><h5 id="python中的锁："><a class="headerlink" href="#python中的锁："></a>python中的锁：</h5><p>python的threading模块提供了RLock锁解决方法。在某一时间只能让一个线程操作的语句放到RLock的acquire方法和release方法之间，即acquire相当于给RLack上锁，而release相当于解锁</p><p>&lt;!–code￼7–&gt;</p><h5 id="python中的条件锁"><a class="headerlink" href="#python中的条件锁"></a>python中的条件锁</h5><h6 id="threading-Condition-lock-None"><a class="headerlink" href="#threading-Condition-lock-None"></a>threading.Condition(lock=None)</h6><p>实现条件对象的类。它具有如下方法：</p><ul><li>acquire(*args)：请求底层锁。</li><li>release()：释放底层锁。</li><li>wait(timeout=None)：等待直到被通知或发生超时。</li><li>wait_for(predicate, timeout=None)：等待直到条件计算为 True，predicate 是一个可调用对象且它的返回值可被解释为一个布尔值。</li><li>notify(n=1)：默认唤醒一个等待该条件的线程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python沙箱逃逸</title>
      <link href="/2024/03/12/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/"/>
      <url>/2024/03/12/Python%E6%B2%99%E7%AE%B1%E9%80%83%E9%80%B8/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="807b3ae87475c70975b4b7d46a0f2ef778e7b012cca6e55e66fdd1d1adc5bbf1">1a833aa8974dfe1cd1818e1a0fb1a7d25df104115e519a254cc89be7815e63149d7b80f14b8e8b9493b0cf8b23c156122af4ecbd59acb5b9d38b587eb3c3c8bb0a7623d1989bf57db82b83071387b0638f76d5e46ca3cc59549ec5e8acfa9c3d7a7c987441ad7bf23121d12a2c83a3e9789485f18a0c6fb7cde18116e9436f5baf714ac84abdad4ea6018cd3a4f940814cd4ef39636d3e237acfafbb9350a50a48ac4db7adee28e9db19853d0382f52549d999984be4d7b0a3a75cf81147e19ff57227f37e51f6fe7823af2bdb7ece6d55be5863609798c6da73185786b24e83ee2073a026083ae28e59c9fea3449314576a1b9481a186257df7c2a68af415b20a4c9585452e277554b882a9920038ea9bf4a14fe481dd744a850fceb0f2963d5b6927e174e423aeaf777e9d8c75af1ebe040987347865b1d6e2eda187d9ed88b700f86fb4de55609749bde86ad0df753f1c614a282bae9633ba92e0fdd1affc1f645c23890c1012d04a70b1a83b4da205158650550413d67d255dbd0d114839e494af2aacb3d0265fb42dd73522eefc4e1b59c30bfedb986d948310385b14fe3ab478079b097a32f78f3a332985cc71ca4652a4f2557aa500d2d854b301081dc549ae26d23ebb24fb885e55f62c5ae90d0261e6dc5034c00bb48cb28a22d570c45fd9eb950d219051d02807eac129b104e545815a6bf99e87c5db05f2e20d35e00fc5d12fa96591c1b3271c8ef75ad3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyjail下</title>
      <link href="/2024/03/04/Pyjail%E4%B8%8B/"/>
      <url>/2024/03/04/Pyjail%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="HNCTF-2022-WEEK2-calc-jail-beginner-level5-JAIL"><a class="headerlink" href="#HNCTF-2022-WEEK2-calc-jail-beginner-level5-JAIL"></a>[HNCTF 2022 WEEK2]calc_jail_beginner_level5(JAIL)</h3><p>&lt;!–code￼0–&gt;</p><h3 id="HNCTF-2022-WEEK2-calc-jail-beginner-level5-1-JAIL"><a class="headerlink" href="#HNCTF-2022-WEEK2-calc-jail-beginner-level5-1-JAIL"></a>[HNCTF 2022 WEEK2]calc_jail_beginner_level5.1(JAIL)</h3><p>先试一下 上一个的payload，发现import未被定义。</p><p>而dir()发现[‘<strong>builtins</strong>’, ‘my_flag’]，则builtins还在</p><p>&lt;!–code￼1–&gt;</p><p>发现open被删了</p><p>那就Show subclasses with tuple</p><p>&lt;!–code￼2–&gt;</p><p>在倒数第六个发现 &lt;class ‘os._wrap_close’&gt;</p><p>&lt;!–code￼3–&gt;</p><h3 id="HNCTF-2022-Week1-lake-lake-lake-JAIL"><a class="headerlink" href="#HNCTF-2022-Week1-lake-lake-lake-JAIL"></a>[HNCTF 2022 Week1]lake lake lake(JAIL)</h3><p>得到附件</p><p>&lt;!–code￼4–&gt;</p><p>这道题的逻辑是输入1和2分别执行func函数和backdoor函数</p><p>func函数有长度限制，backdoor函数没有但是得得到key的值，key显然是一个全局变量，你在func函数输入globals</p><p>&lt;!–code￼5–&gt;</p><p>得到key’的值： ‘a34af94e88aed5c34fb5ccfe08cd14ab’</p><p>&lt;!–code￼6–&gt;</p><h3 id="HNCTF-2022-Week1-l-ke-l-ke-l-ke-JAIL"><a class="headerlink" href="#HNCTF-2022-Week1-l-ke-l-ke-l-ke-JAIL"></a>[HNCTF 2022 Week1]l@ke l@ke l@ke(JAIL)</h3><p>&lt;!–code￼7–&gt;</p><p>可知func长度限制dao了6，这时我们就可以试试之前用过的help函数</p><p>&lt;!–code￼8–&gt;</p><p>当我吗输入__ main __ 的时候我们会得到该模块的帮助。</p><p>然后得到key的值</p><p>&lt;!–code￼9–&gt;</p><h3 id="HNCTF-2022-WEEK2-lak3-lak3-lak3-JAIL"><a class="headerlink" href="#HNCTF-2022-WEEK2-lak3-lak3-lak3-JAIL"></a>[HNCTF 2022 WEEK2]lak3 lak3 lak3(JAIL)</h3><p>&lt;!–code￼10–&gt;</p><p>把函数ban掉了，需要猜对数字才能获取flag</p><p>显而易见正确答案在right_guesser_question_answer里。</p><p>sys._getframe()函数<br>可以调用栈的帧对象，默认参数为0如果传入0那就会获取eval的调用栈帧，所以需要deep一层</p><p>有个小技巧，可以使用__import__(“sys”).<strong>stdout</strong>.write去进行标准输出，这也是上一个非预期的输出方法。</p><p><strong>import</strong>(“sys”).<strong>stdout</strong>.write(str(<strong>import</strong>(‘sys’)._getframe(1)))</p><p>&lt;!–code￼11–&gt;</p><p>发现’/home/ctf/./server.py‘直接调用f_locals查看变量</p><p>&lt;!–code￼12–&gt;</p><p>然后构造payload</p><p>&lt;!–code￼13–&gt;</p><p>&lt;!–code￼14–&gt;</p><h3 id="calc-jail-beginner-level6"><a class="headerlink" href="#calc-jail-beginner-level6"></a>calc_jail_beginner_level6</h3><p>&lt;!–code￼15–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ethernaut</title>
      <link href="/2023/11/27/Ethernaut/"/>
      <url>/2023/11/27/Ethernaut/</url>
      
        <content type="html"><![CDATA[<h3 id="Force"><a class="headerlink" href="#Force"></a>Force</h3><p>&lt;!–code￼0–&gt;</p><h3 id="King"><a class="headerlink" href="#King"></a>King</h3><p>&lt;!–code￼1–&gt;</p><p>要求我们成为国王，并且不再改变。</p><h4 id="Analyse"><a class="headerlink" href="#Analyse"></a>Analyse</h4><p>然而成为国王需要我们msg.value 超过上个国王的prize，并且msg.sender == owner。显然第二个要求成立，但是当我们成为国王后，需要阻止别人超过我们。这时，我们发现receive函数是先转账，然后再修改成为国王的。因此，如果我们拒绝获得转账，那么就可以保持我们是国王了。</p><h4 id="attack"><a class="headerlink" href="#attack"></a>attack</h4><p>我们需要先得到上个国王的prize，只需运行King合约的prize。</p><p>&lt;!–code￼2–&gt;</p><p>&lt;!–code￼3–&gt;</p><p>该函数也就相当于什么的没有，即拒绝转账。</p><h3 id="Re-entrancy"><a class="headerlink" href="#Re-entrancy"></a><strong>Re-entrancy</strong></h3><p>&lt;!–code￼4–&gt;</p><p>要求盗取所有余额。</p><h4 id="Analyse-2"><a class="headerlink" href="#Analyse-2"></a>Analyse</h4><p>是重入攻击，漏洞在于withdraw函数。可以看到他是先调用了<code>msg.sender.call&#123;value:_amount&#125;(&quot;&quot;);</code>然后再在balance里面将存储的余额减去amount。这里就是可重入攻击的关键所在了，因为该函数在发送ether后才更新余额，所以我们可以想办法让它卡在call.value这里不断给我们发送ether，因为call的参数是空，所以会调用攻击合约的fallback函数，我们在fallback函数里面再次调用withdraw，这样套娃，就能将合约里面的钱都偷出来。</p><h4 id="Attack"><a class="headerlink" href="#Attack"></a>Attack</h4><p>&lt;!–code￼5–&gt;</p><p>还有一种是循环调用withdraw函数,并加以限制。</p><p>我们需要进行donate进行转账，来满足第一个条件，所以</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925537.png" alt="屏幕截图 2023-11-27 175711" loading="lazy"></p><p>然后执行attack函数。</p><p>&lt;!–code￼6–&gt;</p><h3 id="Elevator"><a class="headerlink" href="#Elevator"></a><strong>Elevator</strong></h3><p>&lt;!–code￼7–&gt;</p><p>要求到达top floor。</p><p>buliding是一个加载调用者得知的接口。而要想达到top floor。则须经过isLastFloor的检测。然而却需要两次检测，第一次是false，第二次是true。</p><p>&lt;!–code￼8–&gt;</p><p>当我们调用goTo函数时Building building = Building(msg.sender);，将是攻击合约的地址。我们创建isLastFloor，通过跟踪调用次数，来进行检验。</p><h3 id="Privacy"><a class="headerlink" href="#Privacy"></a><strong>Privacy</strong></h3><p>要求unlock为false，</p><p>&lt;!–code￼9–&gt;</p><p>要想解开，需要使 _key == bytes16(data[2]), 也就是说我们需要得到定长数组data的第三个数据。由于变量是私有的，没有getter函数可以直接调用获得存储的key。</p><p>但是可以使用web3库来调用。根据存储的规则，data数组为定长数组，第一个数据存储再slot3，所以data[2]存储在slot5.</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925539.png" alt loading="lazy"></p><p>然后需要前16个字节，两个字符为一个字节，2+2*16=34</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030925540.png" alt loading="lazy"></p><p>得到密钥，然后将其合约填入并调用unlock函数即可通关。</p><h3 id="Gatekeeper-Two"><a class="headerlink" href="#Gatekeeper-Two"></a>Gatekeeper Two</h3><p>&lt;!–code￼10–&gt;</p><p>三个关卡，然后true</p><h4 id="Analyse-3"><a class="headerlink" href="#Analyse-3"></a>Analyse</h4><p>第一关我们可以使用智能合约调用enter，而不是账号。</p><p>第二关，只允许外部调用，不允许合约之间调用。</p><p>&lt;!–code￼11–&gt;</p><p>第三关</p><p>&lt;!–code￼12–&gt;</p><p>uint64(0) – 1，为uint64最大值。</p><p>&lt;!–code￼13–&gt;</p><p>所以只需计算bytes8(keccak256(abi.encodePacked(address(this)))) ^ 0xFFFFFFFFFFFFFFFF</p><h4 id="attack-2"><a class="headerlink" href="#attack-2"></a>attack</h4><p>&lt;!–code￼14–&gt;</p><h3 id="Naught-Coin"><a class="headerlink" href="#Naught-Coin"></a>Naught Coin</h3><p>&lt;!–code￼15–&gt;</p><p>要求代币变为0即可。</p><p>ERC20标准转账代币有两种方式，transfer以及transferFrom，但是transfer被重写了，所以只能用</p><p>&lt;!–code￼16–&gt;</p><p>但是转帐前，需要approver授权。</p><p>&lt;!–code￼17–&gt;</p><h3 id="Preservation"><a class="headerlink" href="#Preservation"></a><strong>Preservation</strong></h3><p>&lt;!–code￼18–&gt;</p><p>要求获得合约所有权。</p><p>本题的关键就是delegatecall函数，该函数调用后内置变量 <code>msg</code> 的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）。也就是说</p><p>&lt;!–code￼19–&gt;</p><p>当这两个函数调用时，他们改变的是slot0的变量，而我们要求改变合约的拥有者，即slot2处的变量。而这两个合约的变量分布为</p><p>&lt;!–code￼20–&gt;</p><p>&lt;!–code￼21–&gt;</p><p>所以当我们调用setFirstTime函数时，我们调用的是setTime函数。因此，我们可以将timeZone1Library的地址改为攻击合约的地址，然后在攻击合约中写一个setime函数，当执行imeZone1Library.delegatecall(abi.encodePacked(setTimeSignature, _timeStamp));时，就可以调用攻击合约的setime函数。</p><p>我们需要注意owner占据slot2 的低20个字节即可</p><p>&lt;!–code￼22–&gt;</p><p>部署完成后，执行await contract.setFirstTime(‘攻击合约’)</p><p>然后再执行 await contract.setFirstTime(‘player’)就可以了。</p><h3 id="Recovery"><a class="headerlink" href="#Recovery"></a><strong>Recovery</strong></h3><p>&lt;!–code￼23–&gt;</p><p>从合约地址找回丢失的0.5eth</p><h4 id="Analyse-4"><a class="headerlink" href="#Analyse-4"></a>Analyse</h4><p>通过自毁函数进行转账</p><p>&lt;!–code￼24–&gt;</p><p>更新msg.sender余额</p><p>&lt;!–code￼25–&gt;</p><p>只需找到合约地址实行自毁函数将eth转会玩家地址就行。</p><h5 id="寻找地址"><a class="headerlink" href="#寻找地址"></a>寻找地址</h5><ol><li><p>通过etherscan进行查找</p></li><li><p>计算得到</p><p>&lt;!–code￼26–&gt;</p></li></ol><h4 id="Attack-2"><a class="headerlink" href="#Attack-2"></a>Attack</h4><p>&lt;!–code￼27–&gt;</p><p>部署后运行 exploit函数就行。</p><h3 id="MagicNumber"><a class="headerlink" href="#MagicNumber"></a><strong>MagicNumber</strong></h3><p>&lt;!–code￼28–&gt;</p><p>&lt;!–code￼29–&gt;</p><h4 id="合约创建"><a class="headerlink" href="#合约创建"></a>合约创建</h4><p><a href="https://medium.com/coinmonks/ethernaut-lvl-19-magicnumber-walkthrough-how-to-deploy-contracts-using-raw-assembly-opcodes-c50edb0f71a2">Ethernaut Lvl 19 MagicNumber Walkthrough: How to deploy contracts using raw assembly opcodes | by Nicole Zhu | Coinmonks | Medium</a></p><ol><li><p>首先，用户或合约想以太坊发送交易。包括数据但没有接受人的地址（没有 <code>to</code> 地址）。此格式向 EVM 指示是 ，而不是常规发送/调用事务。<code>contract creation</code></p></li><li><p>然后,EVM将solidity中的代码翻译为字节码，可直接转为操作码，在单个调用栈堆中执行。需要注意的重要一点：字节码包含 1） 和 2） 合约的实际值，按顺序连接。<code>contract creation</code>：<code>initialization code``runtime code</code></p></li><li><p>在congtract creation期间，EVM仅仅执行initialzation code，知道到达栈堆中第一条stop或start令，在此期间，合约的contructor会执行，合约就有地址了。在运行 <code>initialization code</code> 后，只有 <code>runtime code</code> 在堆栈上，然后将这些 <strong>opcode</strong> <strong>拷贝</strong> 到 <code>memory</code> 并返回到 <code>EVM</code></p></li><li><p>最后，EVM将runtime code返回的opcode存储在state storage，并于新地址相关联，合约被调用时，这些runtime code将会执行。</p></li></ol><h4 id="Analyse-5"><a class="headerlink" href="#Analyse-5"></a>Analyse</h4><ul><li><p>所以为了解决该题，我们需要</p><p>&lt;!–code￼30–&gt;</p><p>&lt;!–code￼31–&gt;</p><ul><li><code>initialization opcodes</code>: 由 <code>EVM</code> 运行创建合约并存储将来要用的 <code>runtime codes</code></li><li><code>runtime codes</code>: 包含所需的实际执行逻辑。对于本题来说，这是应该返回的代码的主要部分，应该 <strong>return 42</strong> 并且 <strong>under 10 opcodes</strong></li></ul></li></ul><h5 id="runtime-codes"><a class="headerlink" href="#runtime-codes"></a>runtime codes :</h5><p>返回值由 return(p,s)，在此之前，使用mstore（p，v）储存在内存中</p><p>&lt;!–code￼32–&gt;</p><p>&lt;!–code￼33–&gt;</p><p>runtime codes ：302a60805260206080f3 正好10 opcodes</p><h5 id="initialization-codes"><a class="headerlink" href="#initialization-codes"></a>initialization codes</h5><p>&lt;!–code￼34–&gt;</p><p>&lt;!–code￼35–&gt;</p><ul><li><code>initialization codes</code> 总共占了 <strong>0x0c</strong> 字节，这表示 <code>runtime codes</code> 从索引 <strong>0x0c</strong> 开始，所以 <strong>??</strong> 的地方是 <strong>0x0c</strong></li><li>所以，<code>initialization codes</code> 最后的顺序是 <strong>600a600c600039600a6000f3</strong></li></ul><p>initialization codes：600a600c600039600a6000f3</p><h4 id="Solution"><a class="headerlink" href="#Solution"></a>Solution</h4><p>opcodes  ：<strong>0x600a600c600039600a6000f3602a60805260206080f3</strong></p><p>&lt;!–code￼36–&gt;</p><h3 id="Alien-Codex"><a class="headerlink" href="#Alien-Codex"></a>Alien Codex</h3><p>&lt;!–code￼37–&gt;<br>&lt;!-- You’ve uncovered an Alien contract. Claim ownership to complete the level.</p><p>Things that might help</p><p>Understanding how array storage works<br>Understanding ABI specifications<br>Using a very underhanded approach --&gt;</p><p>&lt;!–code￼38–&gt;</p><h4 id="Analyse-6"><a class="headerlink" href="#Analyse-6"></a>Analyse</h4><p>要求获得owner的权限，合约继承自Owenable合约，其中有 _owenr状态变量，则可以推出存储布局<br>&lt;!–code￼39–&gt;<br>可以看出codex长度没有设置，可以通过retract函数可以使数组长度溢出，然后可以通过revise方法进行数组赋值。所以，本题可以codex数组溢出到slot0来修改owner的存储。<br>x=keccak256(bytes32(1))) ，那么当我们修改 codex[y],(y=2^256-x+0) 时就能修改 slot 0 ，从而修改 owner。<br>但是由于函数修改器的存在，我们需要使用makeContact()函数来解除限制。</p><h4 id="Attack-3"><a class="headerlink" href="#Attack-3"></a>Attack</h4><p>第一步我们先解除限制<br>&lt;!–code￼40–&gt;<br>然后使用retract实现数组溢出<br>&lt;!–code￼41–&gt;<br>由于数组长度没有定义，所以为0，只要调用retract()函数，就会溢出，然后调用revise()函数修改数组长度，从而修改owner。<br>然后只需修改codex[2^256 - keccak256(1)]的值就可以改变owner。<br>&lt;!–code￼42–&gt;<br>y = 2^256 - keccak256(1)=0x4ef1d2ad89edf8c4d91132028e8195cdf30bb4b5053d4f8cd260341d4805f30a<br>然后调用revise函数，第二个参数必须补全32位。<br>&lt;!–code￼43–&gt;<br>然后就可以通关了。</p><h3 id="Denial"><a class="headerlink" href="#Denial"></a>Denial</h3><p>&lt;!–code￼44–&gt;<br>这是一个简单的钱包，会随着时间的推移而流失资金。您可以成为提款伙伴，慢慢提款。<br>通关条件： 在owner调用withdraw()时拒绝提取资金（合约仍有资金，并且交易的gas少于1M<br>要求阻止提取资金。</p><p>transfer与send相似，都为转账操作<br>transfer出错抛出异常<br>send、call出错不抛出异常，返回true或false<br>tansfer相对send更安全<br>send、call即便转账失败也会执行其后的代码<br>慎用call函数转账，容易发生重入攻击。</p><h4 id="Analyse-7"><a class="headerlink" href="#Analyse-7"></a>Analyse</h4><p>本题会通过call以及transfer函数来进行转账。每当用户提款时，会调用withdraw函数，取出1%发给partner，还有1%发给owner.<br>本题代码漏洞在于call函数没有检查返回值和指定gas。所以如果在调用call函数时消耗了所有的gas，那么call函数就会 触发 out of gas错误，而之后的transfer函数也会因为gas不足而导致失败。<br>这里有两种思路，一种是通过循环不断消耗gas，另外一种是通过assert来做条件检查</p><p>assert 抛出panic错误时会终止执行。</p><h4 id="Attack-4"><a class="headerlink" href="#Attack-4"></a>Attack</h4><h5 id="第一种"><a class="headerlink" href="#第一种"></a>第一种</h5><p>&lt;!–code￼45–&gt;</p><h5 id="第二种"><a class="headerlink" href="#第二种"></a>第二种</h5><p>&lt;!–code￼46–&gt;<br>然后执行await contract.setWithdrawPartner(“0x03e1a1cf7fc319822355dce72c50b368094546ef”)</p><h3 id="Shop"><a class="headerlink" href="#Shop"></a>Shop</h3><p>&lt;!–code￼47–&gt;<br>Сan you get the item from the shop for less than the price asked?</p><p>Things that might help:<br>Shop expects to be used from a Buyer<br>Understanding restrictions of view functions<br>要求少于规定的price。提供price查询方法，当购买时查询一下buyer.price。购买成功后记录buyer.price。也就是我们只要在成功购买后给一个更低的price即可。<br>本题是一个购买合约，要求购买时价格小于规定的价格。</p><h4 id="Analyse-8"><a class="headerlink" href="#Analyse-8"></a>Analyse</h4><p>&lt;!–code￼48–&gt;<br>发现第一次使用buy函数时时false，但是当第二次使用该函数的时候，isSold为true，就在这里修改price即可。</p><h4 id="Attack-5"><a class="headerlink" href="#Attack-5"></a>Attack</h4><p>&lt;!–code￼49–&gt;<br>根据isSold（）函数修改price（）函数的返回值</p><h3 id="Dex"><a class="headerlink" href="#Dex"></a>Dex</h3><p>&lt;!–code￼50–&gt;</p><p>&lt;!–code￼51–&gt;<br>通关条件： 获取内部所有代币，dex拥有100 token1 和100 token2，而合约拥有10 token1 和10 token2。</p><h4 id="Analyse-9"><a class="headerlink" href="#Analyse-9"></a>Analyse</h4><p>先看SwappableToken<br>&lt;!–code￼52–&gt;<br>简单的ERC20代币，在构造函数中为msg.sender发行initialSupply数量，重写approve，防止_dex授权<br>再看Dex ，主要实现了token1和token2的交换<br>&lt;!–code￼53–&gt;<br>第一个require检测token1到token2的交换或者反过来。<br>然后是计算兑换价格<br>&lt;!–code￼54–&gt;<br>也就是说当兑换token y的时候，amount* token y的余额/token x的余额，而solidity的计算是向下取整的。</p><h4 id="Attack-6"><a class="headerlink" href="#Attack-6"></a>Attack</h4><p>最开始我们是10a和10b，dex则是100a和100b，所以第一次计算就变成了0a和20b，dex变成110a和90b。第二次兑换就变成了20*110b/90a=24a<br>所以依次计算。</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">token1</th><th style="text-align:left">token2</th></tr></thead><tbody><tr><td style="text-align:left">initialize</td><td style="text-align:left">pool</td><td style="text-align:left">100</td><td style="text-align:left">100</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">10</td><td style="text-align:left">10</td></tr><tr><td style="text-align:left">token1-&gt; token2: 10</td><td style="text-align:left">pool</td><td style="text-align:left">110</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">0</td><td style="text-align:left">24</td></tr><tr><td style="text-align:left">token2-&gt;token1: 20</td><td style="text-align:left">pool</td><td style="text-align:left">86</td><td style="text-align:left">110</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">24</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">token1-&gt;token2: 24</td><td style="text-align:left">pool</td><td style="text-align:left">110</td><td style="text-align:left">80</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">0</td><td style="text-align:left">30</td></tr><tr><td style="text-align:left">token2-&gt; token1: 30</td><td style="text-align:left">pool</td><td style="text-align:left">69</td><td style="text-align:left">110</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">41</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">token1-&gt;token2: 41</td><td style="text-align:left">pool</td><td style="text-align:left">110</td><td style="text-align:left">45</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">0</td><td style="text-align:left">65</td></tr><tr><td style="text-align:left">token2-&gt;token1: 45</td><td style="text-align:left">pool</td><td style="text-align:left">110</td><td style="text-align:left">90</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">45</td><td style="text-align:left">110</td></tr><tr><td style="text-align:left">&lt;!–code￼55–&gt;</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h3 id="Dex-Two"><a class="headerlink" href="#Dex-Two"></a>Dex Two</h3><p>&lt;!–code￼56–&gt;<br>题目要求将合约里的两个 token 数量全部取出，允许自己发行自定义 token</p><h4 id="Analyse-10"><a class="headerlink" href="#Analyse-10"></a>Analyse</h4><p>本官swap函数没有</p><p>require((from == token1 &amp;&amp; to == token2) || (from == token2 &amp;&amp; to == token1), “Invalid tokens”);</p><p>这句话做检查，说明攻击者允许出售任意一个from代币从Dex中获得真正的to代币，可以新的代币合约</p><p>那么我们只需要发送一个faketoken到dex合约，我们就可以交换100个faketoken来换回token1，然后重复操作换回token2即可</p><table><thead><tr><th style="text-align:left"></th><th style="text-align:left"></th><th style="text-align:left">token1</th><th style="text-align:left">token2</th><th style="text-align:left">token3</th></tr></thead><tbody><tr><td style="text-align:left">initialize</td><td style="text-align:left">pool</td><td style="text-align:left">100</td><td style="text-align:left">100</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">10</td><td style="text-align:left">10</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">token3-&gt;token1: 1</td><td style="text-align:left">pool</td><td style="text-align:left">0</td><td style="text-align:left">100</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">100</td><td style="text-align:left">10</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">token3-&gt;token2: 2</td><td style="text-align:left">pool</td><td style="text-align:left">0</td><td style="text-align:left">0</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left"></td><td style="text-align:left">player</td><td style="text-align:left">100</td><td style="text-align:left">100</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">主要是利用价格计算公式</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr><tr><td style="text-align:left">&lt;!–code￼57–&gt;</td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td><td style="text-align:left"></td></tr></tbody></table><h4 id="Attack-7"><a class="headerlink" href="#Attack-7"></a>Attack</h4><p>&lt;!–code￼58–&gt;<br>然后对目标合约进行授权以及转账</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/1.png" alt loading="lazy"></p><p>&lt;!–code￼59–&gt;</p><h3 id="Puzzle-Wallet"><a class="headerlink" href="#Puzzle-Wallet"></a>Puzzle Wallet</h3><p>&lt;!–code￼60–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CREATE2</title>
      <link href="/2023/11/21/CREATE2/"/>
      <url>/2023/11/21/CREATE2/</url>
      
        <content type="html"><![CDATA[<p><code>EATE2</code> 是以太坊在 “君士坦丁堡” 这次硬分叉升级中引入的一个新操作码，不同于 <code>CREATE</code>，它使用新的方式来计算合约地址，让生成的合约地址更具有可控性。通过 <code>CREATE2</code> 可以延伸出很多有意思的玩法，在 CTF 中最常见的就是利用这种可控性，在同一个地址先后部署字节码完全不同的合约。</p><h2 id="原理"><a class="headerlink" href="#原理"></a>原理</h2><h3 id="CREATE"><a class="headerlink" href="#CREATE"></a>CREATE</h3><p>如果利用外部账户或者使用 <code>CREATE</code> 操作码的合约账户创建一个合约，那么很容易就能确定被创建合约的地址。每个账户都有一个与之关联的 <code>nonce</code>：对外部账户而言，每发送一个交易，<code>nonce</code> 就会随之 <code>+1</code>；对合约账户而言，每创建一个合约，<code>nonce</code> 就会随之 <code>+1</code>。新合约的地址由创建合约交易的发送者账户地址及其 <code>nonce</code> 值计算得到，其具体公式如下：</p><p>&lt;!–code￼0–&gt;</p><h3 id="CREATE2"><a class="headerlink" href="#CREATE2"></a>CREATE2</h3><p>不同于原来的 <code>CREATE</code> 操作码，在合约地址的计算方法上，<code>CREATE2</code> 不再依赖于账户的 <code>nonce</code>，而是对以下参数进行哈希计算，得出新的地址：</p><ul><li>合约创建者的地址（<code>address</code>)</li><li>作为参数的混淆值（<code>salt</code>）</li><li>合约创建代码 (<code>init_code</code>)</li></ul><p>具体的计算公式如下：</p><p>&lt;!–code￼1–&gt;</p><p>一个需要注意的重要细节是，计算合约地址所需的最后一个参数并非合约代码，而是其创建代码。该代码是用来创建合约的，合约创建完成后将返回运行时字节码。</p><p>这意味着，如果我们控制了合约的创建代码并使其保持不变，然后控制合约构造函数返回的运行时字节码，那么我们很容易就能做到在同一个地址上，反复部署完全不同的合约。事实上 <code>CREATE2</code> 这种让合约在部署后可以被重新更改的特性存在着潜在的安全问题，也引起了人们对其的<a href="https://ethereum-magicians.org/t/potential-security-implications-of-create2-eip-1014/2614">讨论</a>。</p><p>在 CTF 中，这种特性往往会被用来作为一个技巧，通过在同一个地址上部署不同的合约用来 bypass 不同的校验。</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>题目</title>
      <link href="/2023/11/20/%E9%A2%98%E7%9B%AE/"/>
      <url>/2023/11/20/%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h3 id="强网拟态2023"><a class="headerlink" href="#强网拟态2023"></a>强网拟态2023</h3><h4 id="国际象棋与二维码"><a class="headerlink" href="#国际象棋与二维码"></a>国际象棋与二维码</h4><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921754.png" alt loading="lazy"></p><p>查看像素以及方格的个数。然后根据给出的题目为国际象棋棋盘。先生成一个500*500像素，行列为49的国际象棋棋盘</p><p>&lt;!–code￼0–&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921755.png" alt loading="lazy"></p><p>然后与该图片进行异或操作</p><p>&lt;!–code￼1–&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921757.png" alt loading="lazy"></p><p>扫码得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030921758.png" alt loading="lazy"></p><h3 id="帕鲁杯"><a class="headerlink" href="#帕鲁杯"></a>帕鲁杯</h3><h4 id="ez-misc"><a class="headerlink" href="#ez-misc"></a>ez_misc</h4><p>给了一个加密的rar文件以及一张图片。在图片最后有this is password的空白隐写</p><p>snow解密得</p><p>.\SNOW.EXE -C .\White.txt<br>Carefree and carefree</p><p>修复rar文件，然后解密得到flag</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Function Selector and Argument Encoding</title>
      <link href="/2023/11/09/Function-Selector-and-Argument-Encoding/"/>
      <url>/2023/11/09/Function-Selector-and-Argument-Encoding/</url>
      
        <content type="html"><![CDATA[<p>在 Ethereum 生态系统中，ABI (Application Binary Interface，应用二进制接口) 是从区块链外部与合约进行交互以及合约与合约间进行交互的一种标准方式。数据会根据其类型按照这份手册中说明的方法进行编码。</p><h3 id="Function-Selector"><a class="headerlink" href="#Function-Selector"></a>Function Selector</h3><h4 id="原理"><a class="headerlink" href="#原理"></a>原理</h4><p>某个函数签名的 Keccak (SHA-3) 哈希的前 4 字节，指定了要调用的函数，形如 bytes4(keccak256(‘balanceOf(address)’)) == 0x70a08231 这种形式，0x70a08231 便是 balanceOf(address) 的 Function Selector</p><ul><li>基础原型即是函数名称加上由括号括起来的参数类型列表，参数类型间由一个逗号分隔开，且没有空格</li><li>对于 uint 类型，要转成 uint256 进行计算，比如 ownerOf(uint256) 其 Function Selector = bytes4(keccak256(‘ownerOf(uint256)’)) == 0x6352211e</li><li>函数参数包含结构体，相当于把结构体拆分成单个参数，只不过这些参数用 <code>()</code> 扩起来</li></ul><h3 id="Argument-Encoding"><a class="headerlink" href="#Argument-Encoding"></a>Argument Encoding</h3><p>从第5字节开始是被编码的参数。这种编码方式也被用在其他地方，比如，返回值和事件的参数也会被用同样的方式进行编码，而用来指定函数的4个字节则不需要再进行编码。</p><h2 id="类型编码"><a class="headerlink" href="#类型编码"></a>类型编码</h2><p>以下是基础类型：</p><ul><li><code>uint&lt;M&gt;</code>： <code>M</code> 位的无符号整数， <code>0 &lt; M &lt;= 256</code>、 <code>M % 8 == 0</code>。例如： <code>uint32</code>， <code>uint8</code>， <code>uint256</code>。</li><li><code>int&lt;M&gt;</code>：以 2 的补码作为符号的 <code>M</code> 位整数， <code>0 &lt; M &lt;= 256</code>、 <code>M % 8 == 0</code>。</li><li><code>address</code>：除了字面上的意思和语言类型的区别以外，等价于 <code>uint160</code>。在计算和 函数选择器Function Selector 中，通常使用 <code>address</code>。</li><li><code>uint</code>、 <code>int</code>： <code>uint256</code>、 <code>int256</code> 各自的同义词。在计算和 函数选择器Function Selector 中，通常使用 <code>uint256</code> 和 <code>int256</code>。</li><li><code>bool</code>：等价于 <code>uint8</code>，取值限定为 0 或 1 。在计算和 函数选择器Function Selector 中，通常使用 <code>bool</code>。</li><li><code>fixed&lt;M&gt;x&lt;N&gt;</code>： <code>M</code> 位的有符号的固定小数位的十进制数字 <code>8 &lt;= M &lt;= 256</code>、 <code>M % 8 == 0</code>、且 <code>0 &lt; N &lt;= 80</code>。其值 <code>v</code> 即是 <code>v / (10 ** N)</code>。（也就是说，这种类型是由 M 位的二进制数据所保存的，有 N 位小数的十进制数值。译者注。）</li><li><code>ufixed&lt;M&gt;x&lt;N&gt;</code>：无符号的 <code>fixed&lt;M&gt;x&lt;N&gt;</code>。</li><li><code>fixed</code>、 <code>ufixed</code>： <code>fixed128x18</code>、 <code>ufixed128x18</code> 各自的同义词。在计算和 函数选择器Function Selector 中，通常使用 <code>fixed128x18</code> 和 <code>ufixed128x18</code>。</li><li><code>bytes&lt;M&gt;</code>： <code>M</code> 字节的二进制类型， <code>0 &lt; M &lt;= 32</code>。</li><li><code>function</code>：一个地址（20 字节）之后紧跟一个 函数选择器Function Selector （4 字节）。编码之后等价于 <code>bytes24</code>。</li></ul><p>以下是定长数组类型：</p><ul><li><p><code>&lt;type&gt;[M]</code>：有 <code>M</code> 个元素的定长数组， <code>M &gt;= 0</code>，数组元素为给定类型。</p><p>注解</p><p>尽管此ABI规范可以表示零个元素的定长数组，但编译器不支持它们。</p></li></ul><p>以下是非定长类型：</p><ul><li><code>bytes</code>：动态大小的字节序列。</li><li><code>string</code>：动态大小的 unicode 字符串，通常呈现为 UTF-8 编码。</li><li><code>&lt;type&gt;[]</code>：元素为给定类型的变长数组。</li></ul><p>可以将若干类型放到一对括号中，用逗号分隔开，以此来构成一个 元组tuple：</p><ul><li><code>(T1,T2,...,Tn)</code>：由 <code>T1</code>，…， <code>Tn</code>， <code>n &gt;= 0</code> 构成的 元组tuple。</li></ul><p>用 元组tuple 构成 元组tuple、用 元组tuple 构成数组等等也是可能的。另外也可以构成“零元组（zero-tuples）”，就是 <code>n = 0</code> 的情况。</p><h4 id="Solidity-到-ABI-类型-映射"><a class="headerlink" href="#Solidity-到-ABI-类型-映射"></a>Solidity 到 ABI 类型 映射</h4><p>Solidity 支持上面介绍的所有同名称的类型，除元组外。 另一方面，一些 Solidity 类型不被 ABI 支持。下表在左栏显示了不支持 ABI 的 Solidity 类型，以及在右栏显示可以代表它们的 ABI 类型。</p><table><thead><tr><th>Solidity</th><th>ABI</th></tr></thead><tbody><tr><td><a href="https://learnblockchain.cn/docs/solidity/types.html#address">address payable</a></td><td><code>address</code></td></tr><tr><td><a href="https://learnblockchain.cn/docs/solidity/contracts.html#contracts">contract</a></td><td><code>address</code></td></tr><tr><td><a href="https://learnblockchain.cn/docs/solidity/types.html#enums">enum</a></td><td><code>uint8</code></td></tr><tr><td><a href="https://learnblockchain.cn/docs/solidity/types.html#user-defined-value-types">user defined value types</a></td><td>its underlying value type</td></tr><tr><td><a href="https://learnblockchain.cn/docs/solidity/types.html#structs">struct</a></td><td><code>tuple</code></td></tr></tbody></table><h3 id="Function-Selector-and-Argument-Encoding"><a class="headerlink" href="#Function-Selector-and-Argument-Encoding"></a>Function Selector and Argument Encoding</h3><ul><li>动态类型的数据，比如动态数组，结构体，变长字节，其编码后存储其 <code>offset</code>、<code>length</code>、<code>data</code><ul><li>先把参数顺序存储：如果是定长数据类型，直接存储其 <code>data</code>，如果是变长数据类型，先存储其 <code>offset</code></li><li>顺序遍历变长数据：先存储 <code>offset</code>，对于第一个变长数据，先存储其 <code>offset = 0x20 * number</code> ( <code>number</code> 是函数参数的个数 )；对于下一个变长数据，其 <code>offset = offset_of_prev + 0x20 + 0x20 * number</code> (第一个 <code>0x20</code> 是存储前一个变长数据的长度占用的大小，<code>number</code> 是前一个变长数据的元素个数)</li><li>顺序遍历变长数据：存储完 <code>offset</code> ，接着就是遍历每个变长数据，分别存储其 <code>length</code> 和 <code>data</code></li><li>( <code>ps:</code> 对于结构体这样的类型，存储的时候可把结构体内元素看成是一个新函数的参数，这样的话，对于结构体中的第一个变长数据，其 <code>offset = 0x20 * num</code> ，<code>num</code> 是结构体元素的个数 )</li></ul></li></ul><p>&lt;!–code￼0–&gt;</p><p>&lt;!–code￼1–&gt;</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Uninitialized Storage Pointer</title>
      <link href="/2023/11/09/Uninitialized-Storage-Pointer/"/>
      <url>/2023/11/09/Uninitialized-Storage-Pointer/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a class="headerlink" href="#原理"></a>原理</h3><p>未初始化的存储指针是指在EVM中未进行初始化的storage变量，这个变量会指向其他变量的区域，从而改变其他变量的值。</p><h3 id="例子"><a class="headerlink" href="#例子"></a>例子</h3><p>&lt;!–code￼0–&gt;</p><p>在setValue设置（1  ,0x10aA1C20aD710B823f8c1508cfC12D5d1199117E）</p><p>这时发现a，b分别为 1  ,0x10aA1C20aD710B823f8c1508cfC12D5d1199117E</p><p>但是当 attack设置（3  ,0xa3b0D4BBF17F38e00F68Ce73f81D122FB1374ff6）</p><p>a和b也就变为了 3  ,0xa3b0D4BBF17F38e00F68Ce73f81D122FB1374ff6</p><p>这是因为在函数内部申明一个变量，通常默认是局部变量。但是Solidity的处理有些问题，在此处反直觉地默认让引用类型（Reference Type）变量，所以存储位置为storage。并且对于未初始化的storage 指针（类似传统语言中的空指针），Solidity 默认其指向 storage 的起始地址，即指向合约开头定义的状态变量。</p><p>也就是说，a指向slot0，b指向slot1.同时， wallet.value指向slot0，wallet.addr指向slot1。</p><p>同理，数组也有同样的问题。</p><p>&lt;!–code￼1–&gt;</p><p>x与someVariable的指向相同。</p><h3 id="修复"><a class="headerlink" href="#修复"></a>修复</h3><p>实际上，这个问题只存在于solidity0.5.0之前的版本，编译器版本为0.4.26的话，报的还只是一个warning，不影响deploy；在下一个版本，0.5.0里面就变成了报error：</p><p>对于结构体，需要使用mapping对结构体进行初始化，并使用storage进行拷贝。</p><p>在 Solidity 中，一个未初始化的结构体并不会占用存储插槽。只有在对结构体进行实例化后，它才会占用实际的存储空间。</p><p>&lt;!–code￼2–&gt;</p><p>数组的修复，则是在生命变量的时候对其初始化操作：</p><p>&lt;!–code￼3–&gt;</p><h3 id="2019-BalsnCTF-Bank"><a class="headerlink" href="#2019-BalsnCTF-Bank"></a>2019 BalsnCTF Bank</h3><p>&lt;!–code￼4–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NSSCTF 刷题</title>
      <link href="/2023/11/06/NSSCTF-%E5%88%B7%E9%A2%98/"/>
      <url>/2023/11/06/NSSCTF-%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="UTCTF-2020-Zero"><a class="headerlink" href="#UTCTF-2020-Zero"></a>[UTCTF 2020]Zero</h3><p>得到附件打开得到</p><p>Lorem ipsum dolor ‌‌‌‌‍﻿‍‍sit amet‌‌‌‌‍﻿‍‌, consectetur adipiscing‌‌‌‌‍‬‍‬ elit.‌‌‌‌‍‬﻿‌‌‌‌‌‍‬‌‍ Phasellus quis tempus ante, nec vehicula mi. ‌‌‌‌‍‬‍﻿Aliquam nec‌‌‌‌‍﻿‬﻿ nisi ut neque interdum auctor.‌‌‌‌‍﻿‍﻿ Aliquam felis ‌‌‌‌‍‬‬‌orci, vestibulum ‌‌‌‌‍﻿‬‍sit amet ante‌‌‌‌‍‌﻿‬ at, consectetur‌‌‌‌‍‌﻿﻿ lobortis eros.‌‌‌‌‍‍‍‌ ‌‌‌‌‍‌‌‌Orci varius natoque ‌‌‌‌‍﻿‌﻿penatibus et ‌‌‌‌‍‬‌﻿magnis‌‌‌‌‌﻿‌‍‌‌‌‌‌﻿‌‍ dis ‌‌‌‌‍‍﻿﻿parturient montes, nascetur ridiculus ‌‌‌‌‌﻿‍‌‌‌‌‌‌﻿‬‍mus. In finibus‌‌‌‌‌﻿‌‬ magna‌‌‌‌‌﻿‍﻿ mauris, quis‌‌‌‌‍‬‌‍ auctor ‌‌‌‌‍‬‌‍libero congue quis. ‌‌‌‌‍‬‬‬Duis‌‌‌‌‍‬‌‬ sagittis consequat urna non tristique. Pellentesque eu lorem ‌‌‌‌‍﻿‌‍id‌‌‌‌‍‬‬﻿ quam vestibulum ultricies vel ac purus‌‌‌‌‌﻿‌‍.‌‌‌‌‌﻿‍‌‌‌‌‌‍﻿﻿‍</p><p>放在kali里面，用vim打开该txt文件，果然发现许多不可见字符，就判断为零宽字符，在线解密得到flag。</p><h3 id="NISACTF-2022-为什么我什么都看不见"><a class="headerlink" href="#NISACTF-2022-为什么我什么都看不见"></a>[NISACTF 2022]为什么我什么都看不见</h3><p>打开附件后，放到010中发现文件头出现错误，补齐文件头。先用binwalk分析，得到rar文件，却什么都没有，后来分析，发现是；lsb隐写，最低位隐写即可。</p><h3 id="LitCTF-2023-两仪生四象-中级"><a class="headerlink" href="#LitCTF-2023-两仪生四象-中级"></a>[LitCTF 2023]两仪生四象 (中级)</h3><p>题目直接给了一个程序。</p><p>&lt;!–code￼0–&gt;</p><p>这段代码是对二进制字符串进行解码的过程。在循环中，每次处理三个字符，也就是一个汉字对应的三个二进制数字。如果这三个数字是有效的，即它们对应的八卦名称在_reverse_hash字典中有定义，那么就将这个八卦名称添加到已解密的字符串Encoded_text中；否则，就添加一个空格。</p><p>这个过程中使用了异常处理机制。如果一个二进制字符串无法找到相应的八卦名称，_reverse_hash[binary_text[i:i+3]]操作将会引发一个KeyError异常。在这种情况下，程序将在字符串encoded_text中添加一个空格，以便在最终解密结果中保留二进制字符串中无法解密的部分位置，并且不会中断整个程序的执行。</p><p>最终，经过循环处理和异常处理，我们就可以获得解密后的明文字符串，它被存储在encoded_text变量中。</p><p>脚本</p><p>&lt;!–code￼1–&gt;</p><p>这段代码是对二进制字符串进行解码的过程。在循环中，每次处理三个字符，也就是一个汉字对应的三个二进制数字。如果这三个数字是有效的，即它们对应的八卦名称在_reverse_hash字典中有定义，那么就将这个八卦名称添加到已解密的字符串Encoded_text中；否则，就添加一个空格。</p><p>这个过程中使用了异常处理机制。如果一个二进制字符串无法找到相应的八卦名称，_reverse_hash[binary_text[i:i+3]]操作将会引发一个KeyError异常。在这种情况下，程序将在字符串encoded_text中添加一个空格，以便在最终解密结果中保留二进制字符串中无法解密的部分位置，并且不会中断整个程序的执行。</p><p>最终，经过循环处理和异常处理，我们就可以获得解密后的明文字符串，它被存储在encoded_text变量中。</p><p>然后再进行二进制转字符串即可得到flag。</p><h3 id="【攻防世界】适合作为桌面"><a class="headerlink" href="#【攻防世界】适合作为桌面"></a>【攻防世界】适合作为桌面</h3><p>binwalk发现zlib但是没有任何用处。</p><p>在stegslove中发现一张图片</p><p>扫码得到</p><p>&lt;!–code￼2–&gt;</p><p>16进制在winhex进制中转换发现具有乱码，但是其中有 1.py和module猜测为pyc文件反编译。</p><p><a href="https://tool.lu/pyc/">python反编译 - 在线工具 (tool.lu)</a></p><p>解密得到python文件，进行调整得到</p><p>&lt;!–code￼3–&gt;</p><h3 id="LitCTF-2023-Take-me-hand-初级"><a class="headerlink" href="#LitCTF-2023-Take-me-hand-初级"></a>[LitCTF 2023]Take me hand (初级)</h3><p>打开流量包<br>首先搜一遍词条，flag，ctf，分组详情，分组列表，分组字节流。<br>在分组字节流里找到flag</p><p>%21经url转换为！%7B,%7D分别为{ }，可得flag</p><h3 id="攻防世界-Cephalopod"><a class="headerlink" href="#攻防世界-Cephalopod"></a>攻防世界 Cephalopod</h3><p>追踪流量包的tcp发现了png文件，放在binwalk以及foremost无法分离，利用</p><p>tcpxtract -f 434c8c0ba659476caa9635b97f95600c.pcap</p><p>提取得到flag。</p><p>也可以在tcp追踪流中复制原始数据，到010中进行还原得到png图片。</p><p>给了一个usbdata经过分析为usb流量</p><p>利用脚本进行提取得到</p><p>&lt;!–code￼4–&gt;</p><p>&lt;!–code￼5–&gt;</p><p>应该是键盘密码</p><p>键盘上 ujko 四个字符把 i 包围起来<br>njk 把 m 围起来<br>tfvbh 中间的是 g<br>yhji 围得是 u<br>则：<br>i m g u l f f l a g i s w e l c o m e t f j n u<br>分一下：<br>im gulf flag is welcome t fjnu</p><p>由于flag是残缺的则补齐 to</p><p>NSSCTF{welcome_to_fjnu}</p><h3 id="NISACTF-2022-流量包里有个熊"><a class="headerlink" href="#NISACTF-2022-流量包里有个熊"></a>[NISACTF 2022]流量包里有个熊</h3><p>添加pcap，导出http得到一张小熊的图片，放在binwalk中进行分析发现隐藏文件分离得到</p><p>flag.txt有一个base解密得到</p><p>this is not the true flag!</p><p>打开rar文件发现两个 flah文件外面的没用打开里面的发现一堆奇怪的字符，rot13后发现似乎是图片的16进制放在010中打开得到图片。</p><p>发现了可能是盲水印，利用工具打开</p><p>即 NSSCTF{S0_clev2l_You}</p><h3 id="陇剑杯-2021-ios"><a class="headerlink" href="#陇剑杯-2021-ios"></a>[陇剑杯 2021]ios</h3><h5 id="（1）"><a class="headerlink" href="#（1）"></a>（1）</h5><p>追踪TCP流得到15字节里的日志。</p><p>发现  hack4sec。</p><p>&lt;!–code￼6–&gt;</p><p>可知ip地址为 3.128.156.159</p><h5 id="（2"><a class="headerlink" href="#（2"></a>（2)</h5><p>发现GitHub开源网站：</p><p>Stowaway</p><p>&lt;!–code￼7–&gt;</p><p>作者名：　ph4ntonn</p><p>项目名：　Stowaway</p><p>软件名　     ios_agent</p><h5 id="（3）"><a class="headerlink" href="#（3）"></a>（3）</h5><p>（1）中得出密钥： hack4sec</p><h5 id="（4）"><a class="headerlink" href="#（4）"></a>（4）</h5><p>这里需要先对TLS数据流进行解密</p><p>首选项，TLS 选择keylog.txt</p><p>数据流过滤为http2,然后对数据流进行盲注分析</p><p>37 34 36 35 35 38 66 33 2D 63 38 34 31 2D 34 35 36 62 2D 38 35 64 37 2D 64 36 63 30 66 32 65 64 61 62 62 32 5A 5A 5A 6A</p><p>hex转字符串  746558f3-c841-456b-85d7-d6c0f2edabb2</p><h3 id="CISCN-2022-初赛-ez-usb"><a class="headerlink" href="#CISCN-2022-初赛-ez-usb"></a>[CISCN 2022 初赛]ez_usb</h3><p>&lt;!–code￼8–&gt;</p><p>&lt;!–code￼9–&gt;</p><h3 id="CISCN-2022-初赛-babydisk"><a class="headerlink" href="#CISCN-2022-初赛-babydisk"></a>[CISCN 2022 初赛]babydisk</h3><p>打开后获得一个wav文件。经过提示，使用deepsound</p><p>发现需要密码，则确定是deepsound隐写</p><p>从网上找到一个脚本</p><p>&lt;!–code￼10–&gt;</p><p>使用脚本获取哈希值，借用kali的john来爆破密码。</p><p>&lt;!–code￼11–&gt;</p><p>&lt;!–code￼12–&gt;</p><p>得到密码为feedback，经过deepsound解密得到key.txt</p><p>e575ac894c385a6f</p><p>利用ftk挂载。在回收站发现了</p><p>$RDWTTK4</p><p>根据key.txt分析猜到加密文件是一个veracrypt。将其作为密码得到一个“spiral”</p><p>上网搜索为螺旋的意思，而且是zip的格式。但是结尾和文件整体很怪。在网上发现螺旋算法。找到解密脚本</p><p>&lt;!–code￼13–&gt;</p><p>得到一张png图片</p><p>去掉开头，发现有49个字符，经过怕方格排序，螺旋得出flag。</p><h3 id="GDOUCTF-2023-pixelart"><a class="headerlink" href="#GDOUCTF-2023-pixelart"></a>[GDOUCTF 2023]pixelart</h3><p>图片打开后会发现许多像素点，在010中发现最后要求图片为320*180.</p><p>得知是将原来的像素为12*12提取。</p><p>&lt;!–code￼14–&gt;</p><p>得到假的flag ，再将得到的图片经过zsteg梭哈得到真正的flag。</p><h3 id="CISCN-2018-Picture"><a class="headerlink" href="#CISCN-2018-Picture"></a>CISCN 2018]Picture</h3><p>附件下载后是一个图片，经010分析后没有任何发现，</p><p>binwalk分离两个文件其中一个是base64编码，发现</p><p>&lt;!–code￼15–&gt;</p><p>文件头是错的，应该是个zip文件，然后Unicode转文本，得到16进制吗，转换得到压缩包，密码根据提示，是一个py的错误提示。</p><p>然后解压缩后得到</p><p>&lt;!–code￼16–&gt;</p><p>搜索得到是一个uuencode编码，直接kali梭哈得到flag。</p><h3 id="安洵杯-2020-王牌特工"><a class="headerlink" href="#安洵杯-2020-王牌特工"></a>[安洵杯 2020]王牌特工</h3><p>文件得到findme</p><p>Linux 在file findme得到了是⼀个 ext3 的磁盘 ，</p><p>在kali使用mount挂载，使用mkdir创建文件夹，然后使用</p><p>mount findme /mnt/c/Users/86157/Desktop/新建文件夹2/1  进行挂载。</p><p>发现了       flagbox   key.txt lost+found</p><p>得到查看key.txt</p><p>&lt;!–code￼17–&gt;</p><p>根据提示使用veracrypt工具</p><p>然后得到一个假的flag，提示回头看看。</p><p>然后使用df检查磁盘空间占用情况</p><p>&lt;!–code￼18–&gt;</p><p>猜测是有两个文件被删除了。然后使用磁盘恢复数据软件 extundelete</p><p>extundelete /dev/loop0 inode 2</p><p>&lt;!–code￼19–&gt;</p><p>猜测是 .coolboy.swp</p><p>extundelete /dev/loop0 --restore-file .coolboy.swp</p><p>cd RECOVERED_FILES</p><p>&lt;!–code￼20–&gt;</p><p>然后得到真的密码，进行解密。</p><p>you_are_a_cool_boy</p><h3 id="羊城杯-2023-ai和nia的交响曲"><a class="headerlink" href="#羊城杯-2023-ai和nia的交响曲"></a>[羊城杯 2023]ai和nia的交响曲</h3><p>文件打开是一个流量包，直接过滤HTTP发现一个上传了png一个含有flag.zip</p><p>导出http进行提取压缩包，经过测试将两个08均改为00即可解开伪加密。然后进行发现有零宽字符的txt文件，</p><p>解密得到提示，我们不得不回去找到图片，导出后发现了是关于像素的图片利用脚本进行解密</p><p>&lt;!–code￼21–&gt;</p><p>直接将像素为200以上的为1其余为0，得到文件</p><p>&lt;!–code￼22–&gt;</p><p>HINT:BV1wW4y1R7Jv&amp;&amp;FLAG1:@i_n1a_l0v3S_</p><p>可以得到一半的flag，然后BV1wW4y1R7Jv是一个b站视频，经过发现是讲解摩斯密码的，而</p><p>&lt;!–code￼23–&gt;</p><p>应该是对应的时间所带有的字母。</p><p>于是得到flag          NSSCTF{@i_n1a_l0v3S_CAOCAOGAIFAN}</p><h3 id="空白格"><a class="headerlink" href="#空白格"></a>空白格</h3><p>文件打开什么都没有，根据提示发现是空白格</p><h3 id="Sublime-Text"><a class="headerlink" href="#Sublime-Text"></a>Sublime Text</h3><p>一个软件：<a href="https://www.sublimetext.com/">Sublime Text - Text Editing, Done Right</a></p><p>将由空格，制表符，回车组成的不可见放入该软件可以看到空格，制表符，换行符的区别</p><p>​<img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030926122.png" alt loading="lazy"></p><p>在线解码 <a href="https://www.w3cschool.cn/tryrun/runcode?lang=whitespace">whitespace在线运行,在线工具，在线编译IDE_w3cschool</a></p><h3 id="鹤城杯-2021-A-MISC"><a class="headerlink" href="#鹤城杯-2021-A-MISC"></a>[鹤城杯 2021]A_MISC</h3><p>直接给一个压缩包，010观察一下，不是伪加密。结果直接爆破得到 ‘qwer’，然后给出一张图片，发现ihdr出现问题同时感觉图片不全，直接爆破crc修复一下宽高。</p><p>得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030926123.png" alt loading="lazy"></p><p>得到一个流量包，打开post发现是sql时间盲注的过程。</p><p>直接tshark导出</p><p>&lt;!–code￼24–&gt;</p><p><code>urlencoded-form.value</code> 是 tshark 命令中的一个过滤器表达式，用于抓取 HTTP 请求中的 URL 编码表单参数的值。</p><p>得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030926124.png" alt loading="lazy"></p><p>然后脚本提取</p><p>&lt;!–code￼25–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF刷题</title>
      <link href="/2023/11/06/BUUCTF%E5%88%B7%E9%A2%98/"/>
      <url>/2023/11/06/BUUCTF%E5%88%B7%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="SUCTF2018-single-dog"><a class="headerlink" href="#SUCTF2018-single-dog"></a>[SUCTF2018]single dog</h3><p>打开图片binwalk分析得到压缩包，得到一个文件，里面是一堆表情，发现是js加密（其实就是AAEncode加密）</p><p>在控制台粘贴代码，并删去最后一个表情得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030914333.png" alt loading="lazy"></p><h3 id="间谍启示录"><a class="headerlink" href="#间谍启示录"></a>间谍启示录</h3><p>分析光盘没有发现什么，strings 搜flag，得到flag.exe foremost得到，然后双击点开，得到 机密文件.txt</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919055.png" alt loading="lazy"></p><p>隐藏的项目打开还是挺好用的</p><h3 id="小易的U盘"><a class="headerlink" href="#小易的U盘"></a>小易的U盘</h3><p>打开光盘文件，010查看文件头为rar文件，打开autorun.inf文件</p><p>大多数病毒在入侵U盘时，都会在U盘里创建一个autorun.inf文件，再把病毒路径植入到这个程序里，然后才开始搞破坏。</p><p>[AutoRun]<br>Open=autoflag - 副本 (32)‘</p><p>所以直接找该exe文件</p><p>然后strings 提取</p><p>&lt;!–code￼0–&gt;</p><h3 id="HDCTF2019-你能发现什么蛛丝马迹吗"><a class="headerlink" href="#HDCTF2019-你能发现什么蛛丝马迹吗"></a>[HDCTF2019]你能发现什么蛛丝马迹吗</h3><p>volatility分析得到</p><p>分析cmd进程查看</p><p>&lt;!–code￼1–&gt;</p><p>猜测DumpIt.exe有东西，dump下来</p><p>&lt;!–code￼2–&gt;</p><p>然后直接分离</p><p>得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919056.png" alt loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919057.png" alt="00001858" loading="lazy"></p><p>二维码得到 jfXvUoypb8p3zvmPks8kJ5Kt0vmEw0xUZyRGOicraY4=</p><p>由于有key 和 iv 所以直接AES解密 <a href="https://tool.lmeee.com/jiami/aes">在线AES加密解密 - 拉米工具 (lmeee.com)</a></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919058.png" alt loading="lazy"></p><p>py解密</p><p>&lt;!–code￼3–&gt;</p><h3 id="USB"><a class="headerlink" href="#USB"></a>USB</h3><p>给了一个rar文件和key.ftm</p><p>rar文件放入010中提示了</p><p>header crc mismatch in block #3</p><p><a href="https://www.freebuf.com/column/199854.html">CTF解题技能之压缩包分析基础篇 - FreeBuf网络安全行业门户</a></p><p>分析压缩文件的格式发现，233.png文件块的标识出现错误，需将7A改为74，然后就可以解压文件，得到了一张图片，在stegsolve中的blue0通道中发现一张二维码。解码得到ci{v3erf_0tygidv2_fc0}。</p><p>然后分析key文件，直接binwalk分离，得到一个压缩包，里面有一个流量包，由于时usb流量，直接tshark分离，发现是8字节，直接键盘流量解密。得到</p><p>[+] Found : aababacbbdbdccccdcdcdbbcccbcbbcbbaababaaaaaaaaaaaaaaaaaakey{xinan}</p><p>应该是维吉尼亚密码，直接解开，然后是栅栏密码。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919059.png" alt loading="lazy"></p><h3 id="GUET-CTF2019-zips"><a class="headerlink" href="#GUET-CTF2019-zips"></a>[GUET-CTF2019]zips</h3><p>打开压缩包，得到一个新的压缩包。查看文件头，发现是真加密，暴力破解得到 “723456”.</p><p>然后得到111.zip，里面有一个加密文件，是伪加密，解开后得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919060.png" alt loading="lazy"></p><p>steup.sh打开后</p><p>&lt;!–code￼4–&gt;</p><p>知道密码为python当时的时间戳，由于是2019年的题，所以搜了一下，当时的时间戳应该是15开头。</p><p>而flag.zip又有密码，因此掩码爆破得到flag</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919061.png" alt loading="lazy"></p><h3 id="DDCTF2018-流量分析"><a class="headerlink" href="#DDCTF2018-流量分析"></a>[DDCTF2018]流量分析</h3><p>提示一：若感觉在中间某个容易出错的步骤，若有需要检验是否正确时，可以比较MD5: 90c490781f9c320cd1ba671fcb112d1c<br>提示二：注意补齐私钥格式</p><p>打开流量包后发现有tls流量。</p><p>那就wireshark打开，筛选tcp contains “KEY”</p><p>发现有许多的base串</p><p>解码后发现是一张PNG格式的图片</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919062.png" alt loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919063.png" alt loading="lazy"></p><p>将其复制下来，在进行对照，并补全密钥。</p><p>&lt;!–code￼5–&gt;</p><p>在导入tsl密钥，过滤http，即可得到flag</p><h3 id="b01lers2020-image-adjustments"><a class="headerlink" href="#b01lers2020-image-adjustments"></a>[b01lers2020]image_adjustments</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919064.png" alt loading="lazy"></p><p>就是把所有红线全放到上面或者下面，然后使得黑线跟着移动，最终得到flag。</p><p>&lt;!–code￼6–&gt;</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919066.png" alt loading="lazy"></p><h3 id="洞拐洞拐洞洞拐"><a class="headerlink" href="#洞拐洞拐洞洞拐"></a>洞拐洞拐洞洞拐</h3><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919067.png" alt loading="lazy"></p><p>该图有许多黑白像素</p><p>&lt;!–code￼7–&gt;</p><p>在转二进制后，发现是一个wav文件，保存下来，打开</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919068.png" alt loading="lazy"></p><p>发现每秒有十帧，共有八种不同的高度</p><p>&lt;!–code￼8–&gt;</p><h3 id="SUCTF2019-protocol"><a class="headerlink" href="#SUCTF2019-protocol"></a>[SUCTF2019]protocol</h3><p>USB流量导出</p><p>&lt;!–code￼9–&gt;</p><p>什么都没有发现，然后检查流量包发现png</p><p>foremost分离得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919069.png" alt loading="lazy"></p><p>发现十五个字母图片后面有是个黑色图片，继续看流量包</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919070.png" alt loading="lazy"></p><p>发现数据第三个比特有规律变化，前十五个为图片顺序后面使黑色的顺序，对应得到</p><p>&lt;!–code￼10–&gt;</p><h3 id="MRCTF2020-千层套路"><a class="headerlink" href="#MRCTF2020-千层套路"></a>[MRCTF2020]千层套路</h3><p>题目是一个压缩包套娃，密码是该文件的名字</p><p>&lt;!–code￼11–&gt;</p><p>得到qr.zip，打开后发现应该是一个图片</p><p>&lt;!–code￼12–&gt;</p><p>python得到</p><p>&lt;!–code￼13–&gt;</p><p>发现是一个二维码，解码得到flag</p><h3 id="一路到底"><a class="headerlink" href="#一路到底"></a>一路到底</h3><p>题目给了许多txt文件。</p><p>最下面有一个start.txt，打开发现</p><p>&lt;!–code￼14–&gt;</p><p>前面数字hex转化后未504B，下一个则是0304，猜测是一个压缩包。</p><p>&lt;!–code￼15–&gt;</p><p>然后破解密码。</p><p>得到一个png，其实是jpg格式，修改得到图片。</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919071.jpg" alt loading="lazy"></p><h3 id="key不在这里"><a class="headerlink" href="#key不在这里"></a>key不在这里</h3><p>给了一个二维码，解码得到</p><p>&lt;!–code￼16–&gt;</p><p>发现中间有一串数字</p><p>&lt;!–code￼17–&gt;</p><p>猜测是ascii码</p><p>&lt;!–code￼18–&gt;</p><h3 id="DDCTF2018-第四扩展FS"><a class="headerlink" href="#DDCTF2018-第四扩展FS"></a>[DDCTF2018]第四扩展FS</h3><p>binwalk分析图片得到压缩包，再exif找到提示，打开压缩包，得到</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919072.png" alt loading="lazy"></p><p>看提示是词频分析</p><p>&lt;!–code￼19–&gt;</p><h3 id="CTF2019-babyflash"><a class="headerlink" href="#CTF2019-babyflash"></a>[*CTF2019]babyflash</h3><p>一个flash文件利用 jpexi进行分离得到 一个wav文件和一堆二维码部分</p><p>二维码进行组装</p><p>&lt;!–code￼20–&gt;</p><p>wav解开后得到flag</p><p>&lt;!–code￼21–&gt;</p><h3 id="羊城杯-2020-逃离东南亚"><a class="headerlink" href="#羊城杯-2020-逃离东南亚"></a>[羊城杯 2020]逃离东南亚</h3><p>打开是三个压缩包，第一个没有密码，给了一个png图片，发现宽高有问题</p><p>&lt;!–code￼22–&gt;</p><p>修改后得到下一个压缩包的密码</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919073.png" alt loading="lazy"></p><p>明显是brainfuck，但是解密得到乱码失败。猜测解压后应该得到字符串，但是字符串brainfuck加密后应该是++++++++[开头的，与密文不符，尝试在开头加上++++++++后解密成功</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919074.png" alt loading="lazy"></p><p>elf文件打开</p><p>&lt;!–code￼23–&gt;</p><p>&lt;!–code￼24–&gt;</p><p>然后分析wav ，sileneye</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030919075.png" alt loading="lazy"></p><p>第三个文件夹打开</p><p>&lt;!–code￼25–&gt;</p><p>md写了不能明文交流，联想到tab和空格，但是几千个文件，挨个查看不现实，因此考虑写个脚本搜索，由于tab和空格编写的隐藏数据通常是连续的，同时要过滤到常见的双空格和双/t，因此考虑用 \t \t作为搜索字符</p><p>&lt;!–code￼26–&gt;</p><p>打开后发现每个} 后面 有隐写</p><p>&lt;!–code￼27–&gt;</p><p>得到</p><p>&lt;!–code￼28–&gt;</p><p>转ascii</p><p>&lt;!–code￼29–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Ethereum Storage</title>
      <link href="/2023/10/31/Ethereum-Storage/"/>
      <url>/2023/10/31/Ethereum-Storage/</url>
      
        <content type="html"><![CDATA[<h3 id="插槽"><a class="headerlink" href="#插槽"></a>插槽</h3><p>以太坊数据存储会为合约的每项数据指定一个可计算的存储位置，存放在一个容量为2^256超级数组中，数组每个元素为插槽，初始为0.</p><p>&lt;!–code￼0–&gt;</p><p>当数据长度是已知时，其具体的存储位置将在编译时指定，而对于长度不确定的类型（如动态数组、映射），则会按一定规则计算存储位置。以下是对不同类型变量的储存模型的具体分析。</p><h4 id="值类型"><a class="headerlink" href="#值类型"></a>值类型</h4><p>除映射和动态数组之外的所有类型，其数据长度都是已知的，如定长整型 (<code>int</code>/<code>uint</code>/…), 地址 (<code>address</code>), 定长浮点型 (<code>fixed</code>/<code>ufixed</code>/…), 定长字节数组 (<code>bytes1</code>-<code>bytes32</code>)，编译时将严格根据字段排序顺序，从位置 0 开始连续放置在存储中。如果可能的话，大小少于 32 字节的多个变量会被打包到一个插槽中，而当某项数据超过 32 字节，则需要占用多个连续插槽（<code>data.length / 32</code>）。规则如下：</p><ul><li>存储插槽的第一项会以低位对齐（即右对齐）的方式储存。</li><li>基本类型仅使用存储它们所需的字节。</li><li>如果存储插槽中的剩余空间不足以储存一个基本类型，那么它会被移入下一个存储插槽。</li><li>结构和数组数据总是会占用一整个新插槽（但结构或数组中的各项，都会以这些规则进行打包）。</li></ul><p>&lt;!–code￼1–&gt;</p><p>&lt;!–code￼2–&gt;</p><h4 id="映射"><a class="headerlink" href="#映射"></a>映射</h4><p>对于形如 <code>mapping(address =&gt; uint) a;</code> 的映射类型变量，就无法简单仿照值类型按顺序储存了。对于映射，其会根据上节提到的规则占据位置 <code>p</code> 处的一个插槽，但该插槽不会被真正使用。映射中的键 <code>k</code> 所对应的值会位于 <code>keccak256(k . p)</code>， 其中 <code>.</code> 是连接符。如果该值同时是一个非基本类型，则将 <code>keccak256(k . p)</code> 作为偏移量来找到具体的位置。</p><p>&lt;!–code￼3–&gt;</p><p>&lt;!–code￼4–&gt;</p><p>即 p为所存储的插槽的位置。</p><h4 id="动态数组"><a class="headerlink" href="#动态数组"></a>动态数组</h4><p>对于形如 <code>uint[] b;</code> 的动态数组，其同样会占用对应位置 <code>p</code> 处的插槽，用以储存数组的长度，而数组真正的起始点会位于 <code>keccak256(p)</code> 处</p><p>&lt;!–code￼5–&gt;</p><p>&lt;!–code￼6–&gt;</p><h4 id="字节数组和字符串"><a class="headerlink" href="#字节数组和字符串"></a>字节数组和字符串</h4><p>如果 <code>bytes</code> 和 <code>string</code> 的数据很短，那么它们的长度也会和数据一起存储到同一个插槽。具体地说：如果数据长度小于等于 31 字节， 则它存储在高位字节（左对齐），最低位字节存储 <code>length * 2</code>。如果数据长度超出 31 字节，则在主插槽存储 <code>length * 2 + 1</code>， 数据照常存储在 <code>keccak256(slot)</code> 中。</p><h4 id="可见性"><a class="headerlink" href="#可见性"></a>可见性</h4><p>由于以太坊上的所有信息都是公开的，所以即使一个变量被声明为 <code>private</code>，我们仍能读到变量的具体值。</p><p>利用 web3 提供的 <code>web3.eth.getStorageAt()</code> 方法，可以读取一个以太坊地址上指定位置的存储内容。所以只要计算出了一个变量对应的插槽位置，就可以通过调用该函数来获得该变量的具体值。</p><p>调用：</p><blockquote><p>&lt;!–code￼7–&gt;</p></blockquote><p>&lt;!–code￼8–&gt;</p><h3 id="数据储存位置分析"><a class="headerlink" href="#数据储存位置分析"></a>数据储存位置分析</h3><p>&lt;!–code￼9–&gt;</p><h3 id="例子"><a class="headerlink" href="#例子"></a>例子</h3><p>Balsn CTF 2019 的 Bank</p><p>&lt;!–code￼10–&gt;</p><p>&lt;!–code￼11–&gt;</p><p>SafeBox与 FailedAttempt</p><p>&lt;!–code￼12–&gt;</p><p>&lt;!–code￼13–&gt;</p><h4 id="Source"><a class="headerlink" href="#Source"></a>Source</h4><p>&lt;!–code￼14–&gt;</p><h5 id="Analyse"><a class="headerlink" href="#Analyse"></a>Analyse</h5><p>数组codex 为slot1，实际内容存在keccak256(1)开始的位置。</p><p>x=keccak256(bytes32(1)))</p><p>要想修改owner即要修改slot0，storage一共2^256个位置，因此需要修改codex[y]就等于修改owner。其中y=2 ^256-x。</p><p>于此同时数组的长度还是要大于y的，但是retract()可以实现下溢。</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Python 语法知识</title>
      <link href="/2023/10/31/Python-%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86/"/>
      <url>/2023/10/31/Python-%E8%AF%AD%E6%B3%95%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h3 id="切片"><a class="headerlink" href="#切片"></a>切片</h3><p>一个完整的切片是包含三个参数和两个冒号&quot; : &quot; ,用于分隔三个参数(start_index、end_index、step)。</p><h3 id="find"><a class="headerlink" href="#find"></a>find</h3><p>string.find( str, start, end)</p><ul><li>str ：（必选）指定需要检测的字符串</li><li>start ：（可选）开始索引，默认为0 <code>start = 0</code></li><li>end ：（可选）结束索引，默认为字符串的长度 <code>end = len(string)</code></li><li>如果「包含」字符串，就返回字符串的索引</li><li>如果「不包含」字符串，就返回 -1</li></ul><h3 id="lambda"><a class="headerlink" href="#lambda"></a>lambda</h3><p>lambda 表达式也叫做<strong>匿名函数</strong></p><p>&lt;!–code￼0–&gt;</p><h3 id="正则表达式"><a class="headerlink" href="#正则表达式"></a>正则表达式</h3><h4 id="match"><a class="headerlink" href="#match"></a>match</h4><p>&lt;!–code￼1–&gt;</p><h5 id="单字符匹配20211001104058570"><a class="headerlink" href="#单字符匹配20211001104058570"></a>单字符匹配<img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030927613.png" alt="20211001104058570" loading="lazy"></h5><p>[^2345] 不匹配2345中的任意一个</p><p>[a-z3-5] 匹配a-z或者3-5中的字符</p><h5 id="表示数量"><a class="headerlink" href="#表示数量"></a>表示数量</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030927615.png" alt="20211001112641902" loading="lazy"></p><h5 id="匹配边界"><a class="headerlink" href="#匹配边界"></a>匹配边界</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030927616.png" alt="20211001120752216" loading="lazy"></p><h5 id="匹配分组"><a class="headerlink" href="#匹配分组"></a>匹配分组</h5><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030927617.png" alt="20211001181501339" loading="lazy"></p><h4 id="search"><a class="headerlink" href="#search"></a>search</h4><p>match差不多用法，从字符串中进行搜索</p><h4 id="findall"><a class="headerlink" href="#findall"></a>findall</h4><p>从字面意思上就可以看到，findall是寻找所有能匹配到的字符，并以列表的方式返回</p><h4 id="split"><a class="headerlink" href="#split"></a>split</h4><p>对字符串进行分割，并返回一个列表</p><h3 id="列表与元组"><a class="headerlink" href="#列表与元组"></a>列表与元组</h3><h4 id="列表"><a class="headerlink" href="#列表"></a>列表</h4><p>列表所有元素都放在[]，中</p><p>使用append对列表进行更新</p><p>del删除列表中元素</p><h5 id="常用方法"><a class="headerlink" href="#常用方法"></a>常用方法</h5><p>count()</p><p>统计某个元素出现的次数</p><p>index()</p><p>查找某个元素再列表中首次出现的位置，即索引‘</p><p>remove()</p><p>一处某个值的首次匹配项</p><p>sort()</p><p>对列表中的元素进行排序</p><p>copy()</p><p>复制列表</p><h4 id="元组"><a class="headerlink" href="#元组"></a>元组</h4><p>所有元素放在（）中</p><p>元组中元素不能被修改，我们需要重新赋值，同理也只能删除整个元组</p><h5 id="常用方法-2"><a class="headerlink" href="#常用方法-2"></a>常用方法</h5><p>len()</p><p>max(),min()</p><p>tuple()</p><p>将列表转为元组</p><p>&lt;!–code￼2–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python zip</title>
      <link href="/2023/10/31/Python-zip/"/>
      <url>/2023/10/31/Python-zip/</url>
      
        <content type="html"><![CDATA[<h3 id="zipfile"><a class="headerlink" href="#zipfile"></a><strong>zipfile</strong></h3><h4 id="常用模块"><a class="headerlink" href="#常用模块"></a>常用模块</h4><h5 id="ZipFile"><a class="headerlink" href="#ZipFile"></a>ZipFile</h5><p>&lt;!–code￼0–&gt;</p><h5 id="Zipinfo"><a class="headerlink" href="#Zipinfo"></a>Zipinfo</h5><p>&lt;!–code￼1–&gt;</p><h3 id="题目"><a class="headerlink" href="#题目"></a>题目</h3><h4 id="GDOUCTF-2023-Matryoshka"><a class="headerlink" href="#GDOUCTF-2023-Matryoshka"></a>[GDOUCTF 2023]Matryoshka</h4><p>本题是一个压缩包套娃。</p><p>password1000.txt与Matryoshka1000.zip</p><p>其中每一层数字进行递减</p><p>&lt;!–code￼2–&gt;</p><p>密码为算出的结果。但是密码文件的运算逻辑不是平常做的那种。而是，固定下来，从左往右进行运算</p><p>&lt;!–code￼3–&gt;</p><h3 id="参考链接"><a class="headerlink" href="#参考链接"></a>参考链接</h3><p><a href="https://www.cnblogs.com/ManyQian/p/9193199.html">https://www.cnblogs.com/ManyQian/p/9193199.html</a></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 图像处理</title>
      <link href="/2023/10/30/Python-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/"/>
      <url>/2023/10/30/Python-%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h3 id="pillow"><a class="headerlink" href="#pillow"></a>pillow</h3><p>图片通常使用pillow库进行操作。</p><h4 id="常用模块"><a class="headerlink" href="#常用模块"></a>常用模块</h4><h5 id="Image"><a class="headerlink" href="#Image"></a>Image</h5><p>&lt;!–code￼0–&gt;</p><p>提取一部分</p><p>&lt;!–code￼1–&gt;</p><h5 id="ImageDraw"><a class="headerlink" href="#ImageDraw"></a><strong>ImageDraw</strong></h5><p>&lt;!–code￼2–&gt;</p><p>参数：</p><p>fill = fillColor ，填充颜色<br>outline = outlineColor ， 边框颜色</p><p>&lt;!–code￼3–&gt;</p><h3 id="题目"><a class="headerlink" href="#题目"></a>题目</h3><h4 id="天翼杯-2021-rrrgggbbb"><a class="headerlink" href="#天翼杯-2021-rrrgggbbb"></a>[天翼杯 2021]rrrgggbbb</h4><p>分别用StegSolve查看之后，发现分别r0、g0、b0通道的上方有像素点点。</p><p>抽出，发现``BPG<code>头，并且有</code>THE END`标志</p><p>需要把<code>THE END</code>标志及其之后的内容删掉</p><p>&lt;!–code￼4–&gt;</p><p>删去END后面的内容即可得到flag</p><h3 id="Matplotlib-Pyplot"><a class="headerlink" href="#Matplotlib-Pyplot"></a>Matplotlib Pyplot</h3><p>Pyplot 是matplotlib的子库。</p><p>Pyplot 包含一系列绘图函数的相关函数，每个函数会对当前的图像进行一些修改，例如：给图像加上标记，生新的图像，在图像中产生新的绘图区域等等。</p><p>&lt;!–code￼5–&gt;</p><p>引入pyplot库 ，设置别名为plt。</p><ul><li><code>plot()</code>：用于绘制线图和散点图</li><li><code>scatter()</code>：用于绘制散点图</li><li><code>bar()</code>：用于绘制垂直条形图和水平条形图</li><li><code>hist()</code>：用于绘制直方图</li><li><code>pie()</code>：用于绘制饼图</li><li><code>imshow()</code>：用于绘制图像</li><li><code>subplots()</code>：用于创建子图</li></ul><p>&lt;!–code￼6–&gt;</p><p>&lt;!–code￼7–&gt;</p><p><strong>颜色字符：</strong>‘b’ 蓝色，‘m’ 洋红色，‘g’ 绿色，‘y’ 黄色，‘r’ 红色，‘k’ 黑色，‘w’ 白色，‘c’ 青绿色，‘#008000’ RGB 颜色符串。多条曲线不指定颜色时，会自动选择不同颜色。</p><p><strong>线型参数：</strong>‘‐’ 实线，‘‐‐’ 破折线，‘‐.’ 点划线，‘:’ 虚线。</p><p><strong>标记字符：</strong>‘.’ 点标记，‘,’ 像素标记(极小点)，‘o’ 实心圈标记，‘v’ 倒三角标记，‘^’ 上三角标记，‘&gt;’ 右三角标记，‘&lt;’ 左三角标记…等等。</p><p>绘制直线时</p><p>&lt;!–code￼8–&gt;</p><p>只想绘制两个点</p><p>&lt;!–code￼9–&gt;</p><p>如果不指定x的值，那么将会根据y的值来设置</p><p>我们可以使用 pyplot 中的 grid() 方法来设置图表中的网格线。</p><p>&lt;!–code￼10–&gt;</p><p>&lt;!–code￼11–&gt;</p><h4 id="绘制多图"><a class="headerlink" href="#绘制多图"></a>绘制多图</h4><p><strong>subplot()</strong> 方法在绘图时需要指定位置，<strong>subplots()</strong> 方法可以一次生成多个，在调用时只需要调用生成对象的 ax 即可。</p><p>&lt;!–code￼12–&gt;</p><p>subplots()</p><p>&lt;!–code￼13–&gt;</p><ul><li><strong>nrows</strong>：默认为 1，设置图表的行数。</li><li><strong>ncols</strong>：默认为 1，设置图表的列数。</li><li><strong>sharex、sharey</strong>：设置 x、y 轴是否共享属性，默认为 false，可设置为 ‘none’、‘all’、‘row’ 或 ‘col’。 False 或 none 每个子图的 x 轴或 y 轴都是独立的，True 或 ‘all’：所有子图共享 x 轴或 y 轴，‘row’ 设置每个子图行共享一个 x 轴或 y 轴，‘col’：设置每个子图列共享一个 x 轴或 y 轴。</li><li><strong>squeeze</strong>：布尔值，默认为 True，表示额外的维度从返回的 Axes(轴)对象中挤出，对于 N<em>1 或 1</em>N 个子图，返回一个 1 维数组，对于 N*M，N&gt;1 和 M&gt;1 返回一个 2 维数组。如果设置为 False，则不进行挤压操作，返回一个元素为 Axes 实例的2维数组，即使它最终是1x1。</li><li><strong>subplot_kw</strong>：可选，字典类型。把字典的关键字传递给 add_subplot() 来创建每个子图。</li><li><strong>gridspec_kw</strong>：可选，字典类型。把字典的关键字传递给 GridSpec 构造函数创建子图放在网格里(grid)。</li><li>*<strong>*fig_kw</strong>：把详细的关键字参数传给 figure() 函数。</li></ul><p>&lt;!–code￼14–&gt;</p><h4 id="散点图"><a class="headerlink" href="#散点图"></a>散点图</h4><p>可以用plot或scatter</p><p>&lt;!–code￼15–&gt;</p><h4 id="折线图"><a class="headerlink" href="#折线图"></a>折线图</h4><p>&lt;!–code￼16–&gt;</p><h4 id="条形图"><a class="headerlink" href="#条形图"></a>条形图</h4><p>&lt;!–code￼17–&gt;</p><h4 id="直方图"><a class="headerlink" href="#直方图"></a>直方图</h4><p>&lt;!–code￼18–&gt;</p><h4 id="饼状图"><a class="headerlink" href="#饼状图"></a>饼状图</h4><p>&lt;!–code￼19–&gt;</p><h4 id="imshow（）"><a class="headerlink" href="#imshow（）"></a>imshow（）</h4><p>imshow() 函数是 Matplotlib 库中的一个函数，用于显示图像。</p><p>imshow() 函数常用于绘制二维的灰度图像或彩色图像。</p><p>imshow() 函数可用于绘制矩阵、热力图、地图等。</p><p>&lt;!–code￼20–&gt;</p><p>&lt;!–code￼21–&gt;</p><h4 id="imread"><a class="headerlink" href="#imread"></a>imread</h4><p>imread() 方法是 Matplotlib 库中的一个函数，用于从图像文件中读取图像数据。可以裁剪图像，也可以改变图像的颜色。</p><p>imread() 方法返回一个 numpy.ndarray 对象，其形状是 <strong>(nrows, ncols, nchannels)</strong>，表示读取的图像的行数、列数和通道数：</p><ul><li>如果图像是灰度图像，则 nchannels 为 1。</li><li>如果是彩色图像，则 nchannels 为 3 或 4，分别表示红、绿、蓝三个颜色通道和一个 alpha 通道。</li></ul><p>imread() 方法的语法如下：</p><p>&lt;!–code￼22–&gt;</p><p>&lt;!–code￼23–&gt;</p><h4 id="ciscn2023的国粹"><a class="headerlink" href="#ciscn2023的国粹"></a>ciscn2023的国粹</h4><p>根据第一张麻将的图片进行从1开始标记，然后以a.png为横坐标，另一个为纵坐标。</p><p>&lt;!–code￼24–&gt;</p><p>绘图得到</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Delegatecall</title>
      <link href="/2023/10/26/Delegatecall/"/>
      <url>/2023/10/26/Delegatecall/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a class="headerlink" href="#原理"></a>原理</h3><h4 id="三种调用函数"><a class="headerlink" href="#三种调用函数"></a>三种调用函数</h4><p>在 Solidity 中，call 函数簇可以实现跨合约的函数调用功能，其中包括 call、delegatecall 和 callcode 三种方式。</p><p>&lt;!–code￼0–&gt;</p><p>中的内置变量 <code>msg</code> 会随着调用的发起而改变，<code>msg</code> 保存了调用方的信息包括：调用发起的地址，交易金额，被调用函数字符序列等。</p><h5 id="异同点"><a class="headerlink" href="#异同点"></a>异同点</h5><p>call ：调用后会将msg的值修改为调用者，执行环境为被调用的运行环境</p><p>delegatecall: 调用后内置变量 <code>msg</code> 的值不会修改为调用者，但执行环境为调用者的运行环境（相当于复制被调用者的代码到调用者合约）</p><p>callcode: 调用后内置变量 <code>msg</code> 的值会修改为调用者，但执行环境为调用者的运行环境</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240620171818.png" alt loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/20240620171823.png" alt loading="lazy"><br>&lt;!–code￼1–&gt;</p><h3 id="delegatecall的滥用"><a class="headerlink" href="#delegatecall的滥用"></a>delegatecall的滥用</h3><h4 id="威胁分析"><a class="headerlink" href="#威胁分析"></a>威胁分析</h4><p>delegatecall 调用有 <code>address</code> 和 <code>msg.data</code> 两个参数</p><p>若 <code>msg.data</code> 可控，则可调用 <code>address</code> 处任意函数</p><h4 id="原因分析"><a class="headerlink" href="#原因分析"></a>原因分析</h4><p>&lt;!–code￼2–&gt;</p><p>当部署两个合约后，使用外部账户调用withdelegatecall函数。</p><p>A合约中，c=0；b=0；</p><p>B合约中，b=0；c=address (A)</p><p>事实上调用 delegatecall 来使用 Storage 变量时依据并不是变量名，而是变量的存储位，这样的话我们就可以达到覆盖相关变量的目的。</p><h3 id="题目"><a class="headerlink" href="#题目"></a>题目</h3><h4 id="ethernaut-第-16-题"><a class="headerlink" href="#ethernaut-第-16-题"></a><a href="https://ethernaut.openzeppelin.com/">ethernaut</a> 第 16 题</h4><p>&lt;!–code￼3–&gt;</p><h5 id="分析"><a class="headerlink" href="#分析"></a>分析</h5><p>要想改变owner，只有constructor函数，但是有delegatecall漏洞。</p><p>setFirstTime(uint _timeStamp)</p><p>setSecondTime(uint _timeStamp)</p><p>这两个函数是调用setTime函数。也就是说，当我们第一次调用setFirstTime函数时，就会设置solt0为攻击合约的地址，第二次调用该函数时就会调用该合约的函数即，改变的是solt2。</p><p>&lt;!–code￼4–&gt;</p><p>调用attack1().</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pyjail（上）</title>
      <link href="/2023/10/25/Pyjail%E4%B8%8A/"/>
      <url>/2023/10/25/Pyjail%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h3 id="参考链接"><a class="headerlink" href="#参考链接"></a>参考链接</h3><p>[<a href="https://zhuanlan.zhihu.com/p/578966149">PyJail] python沙箱逃逸探究·总览（HNCTF题解） - 知乎 (zhihu.com)</a></p><p><a href="http://lihuaxi.xjx100.cn/news/1475226.html?action=onClick">Python Jail 沙盒逃逸 合集 (xjx100.cn)</a></p><p><a href="https://www.cnblogs.com/mumuhhh/p/17811377.html">Jail 【Python沙箱逃逸问题合集】 - Kicky_Mu - 博客园 (cnblogs.com)</a></p><h3 id="魔术方法"><a class="headerlink" href="#魔术方法"></a>魔术方法</h3><ul><li><ul><li><code>__init__</code>：构造函数。这个在实例化类的时候就会用到，一般是接受类初始化的参数，并且进行一系列初始化操作。</li><li><code>__len__</code>：返回对象的长度。对一个对象<code>a</code>使用<code>len(a)</code>时，会尝试调用<code>a.__len__()</code>。这个做炼丹的同学应该很熟悉，例如要通过继承<code>torch.utils.data.Dataset</code>来实现自己的数据集时，就需要实现这个方法；</li><li><code>__str__</code>：返回对象的字符串表示。对一个对象<code>a</code>使用<code>str(a)</code>时，会尝试调用<code>a.__str__()</code>。这在我们自己实现一些类，譬如复数、二叉树、有限域、椭圆曲线等时，通过实现该方法，能将对象的内容较好地打印出来。（<code>print</code>函数中也会自动调用对象的<code>__str__</code>方法）相似地，还有<code>__int__</code>魔术方法也用于类型转换，不过较少使用；</li><li><code>__getitem__</code>：根据索引返回对象的某个元素。对一个对象<code>a</code>使用<code>a[1]</code>时，会尝试调用<code>a.__getitem__(1)</code>。同样，当我们通过继承<code>torch.utils.data.Dataset</code>来实现自己的数据集时，就需要实现这个方法。有<code>__getitem__</code>，自然也有对应的<code>__setitem__</code>；</li><li><code>__add__</code>、<code>__sub__</code>、<code>__mul__</code>、<code>__div__</code>、<code>__mod__</code>：算术运算，加减乘除模。如对一个对象<code>a</code>使用<code>a+b</code>时，会尝试调用<code>a.__add__(b)</code>。相应地，对于有些运算，对象需放在后面（第二个操作数）的，则需实现<code>__radd__</code>、<code>__rsub__</code>、<code>__rmul__</code>、<code>__rdiv__</code>、<code>__rmod__</code>，如椭圆曲线上的点的倍点运算<code>G -&gt; d * G</code>，就可以通过实现<code>__rmul__</code>来实现。</li><li><code>__and__</code>，<code>__or__</code>、<code>__xor__</code>：逻辑运算，和算术运算类似；</li><li><code>__eq__</code>，<code>__ne__</code>、<code>__lt__</code>、<code>__gt__</code>、<code>__le__</code>、<code>__ge__</code>：比较运算，和算术运算类似；例如<code>'贵州' &gt; '广西'</code>，就会转而调用<code>'贵州'.__gt__('广西')</code>；</li><li><code>__getattr__</code>：对象是否含有某属性。如果我们对对象<code>a</code>所对应的类实现了该方法，那么在调用未实现的<code>a.b</code>时，就会转而调用<code>a.__getattr__(b)</code>。这也等价于用函数的方法调用：<code>getattr(a, 'b')</code>。有<code>__getattr__</code>，自然也有对应的<code>__setattr__</code>；</li><li><code>__subclasses__</code>：返回当前类的所有子类。一般是用在<code>object</code>类中，在<code>object.__subclasses__()</code>中，我们可以找到<code>os</code>模块中的类，然后再找到<code>os</code>，并且执行<code>os.system</code>，实现RCE。</li></ul></li><li><code>dir</code>：查看对象的所有属性和方法。在我们没有思路的时候，可以通过该函数查看所有可以利用的方法；此外，在题目禁用引号以及小数点时，也可以先用拿到类所有可用方法，再索引到方法名，并且通过<code>getattr</code>来拿到目标方法。</li><li><code>chr</code>、<code>ord</code>：字符与ASCII码转换函数，能帮我们绕过一些WAF</li><li><code>globals</code>：返回所有全局变量的函数；</li><li><code>locals</code>：返回所有局部变量的函数；</li><li><code>__import__</code>：载入模块的函数。例如<code>import os</code>等价于<code>os = __import__('os')</code>；</li><li><code>__name__</code>：该变量指示当前运行环境位于哪个模块中。如我们python一般写的<code>if __name__ == '__main__':</code>，就是来判断是否是直接运行该脚本。如果是从另外的地方import的该脚本的话，那<code>__name__</code>就不为<code>__main__</code>，就不会执行之后的代码。更多参考<a href="https://link.zhihu.com/?target=https%3A//www.geeksforgeeks.org/__name__-a-special-variable-in-python/">这里</a>；</li><li><code>__builtins__</code>：包含当前运行环境中默认的所有函数与类。如上面所介绍的所有默认函数，如<code>str</code>、<code>chr</code>、<code>ord</code>、<code>dict</code>、<code>dir</code>等。在pyjail的沙箱中，往往<code>__builtins__</code>被置为<code>None</code>，因此我们不能利用上述的函数。所以一种思路就是我们可以先通过类的基类和子类拿到<code>__builtins__</code>，再<code>__import__('os').system('sh')</code>进行RCE；</li><li><code>__file__</code>：该变量指示当前运行代码所在路径。如<code>open(__file__).read()</code>就是读取当前运行的python文件代码。需要注意的是，<strong>该变量仅在运行代码文件时会产生，在运行交互式终端时不会有此变量</strong>；</li><li><code>_</code>：该变量返回上一次运行的python语句结果。需要注意的是，<strong>该变量仅在运行交互式终端时会产生，在运行代码文件时不会有此变量</strong>。</li></ul><p><strong>breakpoint 函数</strong></p><p>breakpoint()是3.7以后引入的内置函数，可以用于断点调试</p><p>pdb 模块定义了一个交互式源代码调试器，用于 Python 程序。它支持在源码行间设置（有条件的）断点和单步执行，检视堆栈帧，列出源码列表，以及在任何堆栈帧的上下文中运行任意 Python 代码。它还支持事后调试，可以在程序控制下调用。</p><p>在输入 breakpoint() 后可以代开 Pdb 代码调试器，在其中就可以执行任意 python 代码</p><h3 id="思路"><a class="headerlink" href="#思路"></a>思路</h3><p>优先考虑RCE起手式一种是 os.system(‘sh’)进入交互终端，另一种是os.popen(‘ls’).read()</p><p>object.<strong>subclasses</strong>()<code>中找到</code>os<code>模块中的类（一般是</code>&lt;class ‘os._wrap_close’&gt;<code>），另一种是先拿到</code><strong>builtins</strong><code>，再</code><strong>import</strong>(‘os’).system(‘sh’)</p><h3 id="题目"><a class="headerlink" href="#题目"></a>题目</h3><h4 id="calc-jail-beginner"><a class="headerlink" href="#calc-jail-beginner"></a>calc_jail_beginner</h4><p>&lt;!–code￼0–&gt;</p><p>可以根据提示构建payload得到flag</p><p>也可以get交互式shell</p><p>&lt;!–code￼1–&gt;</p><h4 id="calc-jail-beginner-level1"><a class="headerlink" href="#calc-jail-beginner-level1"></a>calc_jail_beginner_level1</h4><p>&lt;!–code￼2–&gt;</p><p>也就是说，我们能通过<code>eval</code>执行任意命令，但是命令不能包含双引号、单引号、反引号、字母<code>i</code>和字母<code>b</code>。许多命令，如<code>import</code>、<code>__builtins__</code>、<code>bytes</code>都无法用。</p><p>Show subclasses with tuple开始</p><p>&lt;!–code￼3–&gt;</p><p>b用不了，因此想到getattr()</p><p>&lt;!–code￼4–&gt;</p><p>但是引号都被banl，可以使用chr函数</p><p>‘<strong>base</strong>’</p><p>&lt;!–code￼5–&gt;</p><p><strong>subclasses</strong></p><p>&lt;!–code￼6–&gt;</p><p>绕过WAF</p><p>&lt;!–code￼7–&gt;</p><p>找到os 在 ().<strong>class</strong>.<strong>base</strong>.<strong>subclasses</strong>()[-4].<strong>init</strong>.<strong>globals</strong><a href="'sh'">’system’</a></p><p>&lt;!–code￼8–&gt;</p><p>绕过WAF</p><p>&lt;!–code￼9–&gt;</p><p>然后进如shell交互界面</p><p>&lt;!–code￼10–&gt;</p><h4 id="calc-jail-beginner-level2"><a class="headerlink" href="#calc-jail-beginner-level2"></a>calc_jail_beginner_level2</h4><p>&lt;!–code￼11–&gt;</p><p>该题要求payload的长度不大于13，那么就不能直接__import__(‘os’).system(‘sh’)</p><p>但是在php命令执行中，有一种参数逃逸</p><p>&lt;!–code￼12–&gt;</p><p>对于这串命令system中POST的参数就会逃逸到参数1中去，对于这个1的长度是没有一点长度限制的</p><p>像这里我们也可以采用类似的手法，想办法搞个命令里面能再输入关键命令，显然<code>input()</code>这个函数就正好符合要求</p><p>&lt;!–code￼13–&gt;</p><p>&lt;!–code￼14–&gt;</p><h4 id="calc-jail-beginner-level2-5"><a class="headerlink" href="#calc-jail-beginner-level2-5"></a>calc_jail_beginner_level2.5</h4><p>&lt;!–code￼15–&gt;</p><p>限制长度不大于13，且ban掉了 exec，input，eval</p><p>经过查阅发现可以使用breakpoint()函数进入pdb调试模式，先用step进入模块，可以说使用list检查代码，发现内容被input_data变量接收</p><p>对其进行赋值。</p><p>&lt;!–code￼16–&gt;</p><h4 id="calc-jail-beginner-level3"><a class="headerlink" href="#calc-jail-beginner-level3"></a>calc_jail_beginner_level3</h4><p><a href="https://cheatsheet.haax.fr/linux-systems/programing-languages/python/#pyjail-generate-a-shell">Offensive Security Cheatsheet (haax.fr)</a></p><p>&lt;!–code￼17–&gt;</p><p>由于限定大小不大于7，那么之前的payload就不行了。查看大佬的wp，发现在python交互式终端中，可以使用help函数来进行rce</p><p>入交互式后，随便查询一种用法，由于太多，会使用more进行展示，造成溢出，在后面使用!命令即可造成命令执行。</p><p>&lt;!–code￼18–&gt;</p><p>输入!sh就可以进入shell里面</p><p>&lt;!–code￼19–&gt;</p><h4 id="calc-jail-beginner-level4"><a class="headerlink" href="#calc-jail-beginner-level4"></a>calc_jail_beginner_level4</h4><p>&lt;!–code￼20–&gt;</p><p>&lt;!–code￼21–&gt;</p><p>但是这里可以使用bytes函数以及deocode函数</p><p>bytes 函数可以接收一个 ascii 列表，然后转换为二进制字符串，再调用 decode 则可以得到字符串</p><p>&lt;!–code￼22–&gt;</p><p>&lt;!–code￼23–&gt;</p><p>&lt;!–code￼24–&gt;</p><h4 id="calc-jail-beginner-level4-0-5"><a class="headerlink" href="#calc-jail-beginner-level4-0-5"></a>calc_jail_beginner_level4.0.5</h4><p>&lt;!–code￼25–&gt;</p><p>没有给源码，但是有提示，与上一个相同。</p><h4 id="calc-jail-beginner-level4-1"><a class="headerlink" href="#calc-jail-beginner-level4-1"></a>calc_jail_beginner_level4.1</h4><p>&lt;!–code￼26–&gt;</p><p>依然没有源码，但是bytes被ban了，那么从类中找到第六个 &lt;class ‘bytes_iterator’&gt;</p><p>那么构造bytes ：</p><p>&lt;!–code￼27–&gt;</p><p>&lt;!–code￼28–&gt;</p><h4 id="calc-jail-beginner-level4-2"><a class="headerlink" href="#calc-jail-beginner-level4-2"></a>calc_jail_beginner_level4.2</h4><p>&lt;!–code￼29–&gt;</p><p>第一种方法还是之前bytes被ban的情况。</p><p>另一中方法则是使用doc函数</p><p>但是由于+以及’被ban了可以先用join方法，然后用str()来绕过’</p><p>&lt;!–code￼30–&gt;</p><h4 id="calc-jail-beginner-level4-3"><a class="headerlink" href="#calc-jail-beginner-level4-3"></a>calc_jail_beginner_level4.3</h4><p>&lt;!–code￼31–&gt;</p><p>依然可以用上面的payload。</p><h4 id="CISCN-2023-初赛-pyshell"><a class="headerlink" href="#CISCN-2023-初赛-pyshell"></a>[CISCN 2023 初赛]pyshell</h4><p>有长度限制，使用’__'进行字符串拼接</p><p>python中_表示上次计算结果，因此可以进行_进行字符串拼接</p><p>&lt;!–code￼32–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GETH 搭建私链</title>
      <link href="/2023/10/24/GETH-%E6%90%AD%E5%BB%BA%E7%A7%81%E9%93%BE/"/>
      <url>/2023/10/24/GETH-%E6%90%AD%E5%BB%BA%E7%A7%81%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h3 id="1-下载客户端"><a class="headerlink" href="#1-下载客户端"></a>1.下载客户端</h3><p>在下载geth时，要注意版本不要太高，最新版本的geth不支持搭建私链。</p><p>这里是11.6版本。</p><h3 id="2-准备创世块的配置文件"><a class="headerlink" href="#2-准备创世块的配置文件"></a>2.准备创世块的配置文件</h3><p>&lt;!–code￼0–&gt;</p><h3 id="3-初始化写入创世区块"><a class="headerlink" href="#3-初始化写入创世区块"></a>3.初始化写入创世区块</h3><p>&lt;!–code￼1–&gt;</p><h3 id="4-启动geth"><a class="headerlink" href="#4-启动geth"></a>4.启动geth</h3><p>&lt;!–code￼2–&gt;</p><ol><li><strong>./geth</strong>：这是执行 Geth 客户端的命令。</li><li><strong>–datadir data1</strong>：这个选项指定了数据目录的路径，Geth 将在这个目录中存储区块链数据和相关文件。</li><li><strong>–networkid 10</strong>：指定私有链的网络标识符，这个值用于在不同私有链之间进行区分。</li><li><strong>–http</strong>：启用 HTTP-RPC 通信接口，允许通过 HTTP 请求与 Geth 进行交互。</li><li><strong>–http.addr 0.0.0.0</strong>：设置 HTTP-RPC 服务监听的地址，0.0.0.0 表示允许来自任何 IP 地址的连接。</li><li><strong>–http.port 8545</strong>：指定 HTTP-RPC 服务的端口号，一般是 8545。</li><li><strong>–http.corsdomain “*”</strong>：配置允许跨域请求的域名，设置为 “*” 表示允许任何域名进行跨域请求。</li><li><strong>–http.api “db,eth,net,web3,personal,web3”</strong>：指定启用的 HTTP-RPC 接口，这里列出了一些常用的接口，包括数据库、以太坊操作、网络信息、Web3 功能和个人账户操作。</li><li><strong>–port 30305</strong>：设置 Geth 节点的 P2P 网络端口，用于节点间的通信。</li><li><strong>-allow-insecure-unlock</strong>：允许以不安全的方式解锁账户。这在测试环境中使用，允许在 HTTP-RPC 上发送解锁账户的请求，但在生产环境中不建议使用</li></ol><p>web3.fromWei(eth.getBalance(eth.coinbase), “ether”);</p><h3 id="参考网站"><a class="headerlink" href="#参考网站"></a>参考网站</h3><p><a href="https://www.bilibili.com/read/cv25915543/">一步步教程：使用Geth在本地搭建私有以太坊区块链 - 哔哩哔哩 (bilibili.com)</a></p><p><a href="https://www.cnblogs.com/shuhai165/p/16623128.html#autoid-0-0-0">Win10使用Geth客户端搭建以太坊私有链、连接可视化钱包 - 樹海 - 博客园 (cnblogs.com)</a></p><h3 id="web3的异常"><a class="headerlink" href="#web3的异常"></a>web3的异常</h3><p>&lt;!–code￼3–&gt;</p><p>解决方案</p><p><a href="https://blog.csdn.net/weixin_44322508/article/details/134130583">https://blog.csdn.net/weixin_44322508/article/details/134130583</a></p><h3 id="在线挖矿"><a class="headerlink" href="#在线挖矿"></a>在线挖矿</h3><p><a href="http://www.snowywar.top/?golink=aHR0cHM6Ly9zZXBvbGlhLWZhdWNldC5wazkxMC5kZS8=">Sepolia PoW Faucet (pk910.de)</a></p><p><a href="http://www.snowywar.top/?golink=aHR0cHM6Ly9nb2VybGktZmF1Y2V0LnBrOTEwLmRlLw==">Goerli PoW Faucet (pk910.de)</a></p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Airdrop Hunting</title>
      <link href="/2023/10/24/Airdrop-Hunting/"/>
      <url>/2023/10/24/Airdrop-Hunting/</url>
      
        <content type="html"><![CDATA[<h3 id="原理"><a class="headerlink" href="#原理"></a>原理</h3><p>薅羊毛攻击指使用多个不同的新账户来调用空投函数获得空投币并转账至攻击者账户以达到财富累计的一种攻击方式。这类攻击方式较为普通且常见，只要是有空投函数的合约都能够进行薅羊毛。</p><h3 id="例子"><a class="headerlink" href="#例子"></a>例子</h3><p>数字经济大赛 2019 的 jojo</p><p>&lt;!–code￼0–&gt;</p><p>分析如果想要出发flag函数需要余额&gt;=100000； 而单单gift()函数一次只能增加余额100，所以可以创建1000个临时合约来调用空投函数，并进行转账。</p><p>&lt;!–code￼1–&gt;</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Randomness</title>
      <link href="/2023/10/22/Randomness/"/>
      <url>/2023/10/22/Randomness/</url>
      
        <content type="html"><![CDATA[<h4 id="使用私有变量的伪随机数"><a class="headerlink" href="#使用私有变量的伪随机数"></a>使用私有变量的伪随机数</h4><h5 id="原理"><a class="headerlink" href="#原理"></a>原理</h5><p>合约使用外界未知的私有变量参与随机数生成。无法通过另一合约访问，但是变量储存进 storage 之后仍然是公开的。我们可以使用区块链浏览器（如 etherscan）观察 storage 变动情况，或者计算变量储存的位置并使用 Web3 的 api 获得私有变量值，然后计算得到随机数。</p><h4 id="外部参与的随机数"><a class="headerlink" href="#外部参与的随机数"></a>外部参与的随机数</h4><h5 id="原理-2"><a class="headerlink" href="#原理-2"></a>原理</h5><p>随机数由其他服务端生成。为了确保公平，服务端会先将随机数或者其种子的哈希写入合约中，然后待用户操作之后再公布哈希对应的明文值。由于明文空间有 256 位，这样的随机数生成方法相对安全。但是在明文揭露时，我们可以在状态为 pending 的交易中找到明文数据，并以更高的 gas 抢在之前完成交易确认。</p><h4 id="使用区块变量的伪随机数"><a class="headerlink" href="#使用区块变量的伪随机数"></a>使用区块变量的伪随机数</h4><h5 id="原理-3"><a class="headerlink" href="#原理-3"></a>原理</h5><p>EVM 有五个字节码可以获取当前区块的变量，包括 coinbase、timestamp、number、difficulty、gaslimit。</p><p>我们也可以编写攻击合约，在攻击合约中获取到相同的区块变量值，进一步用相同的算法得到随机数值。</p><h5 id="例子"><a class="headerlink" href="#例子"></a>例子</h5><p>&lt;!–code￼0–&gt;</p><ul><li>代码处理流程为：<ul><li>获得上一块的 hash 值（    uint256 blockValue = uint256(block.blockhash(block.number.sub(1)));）</li><li>判断与之前保存的 hash 值是否相等，相等则会退（if (lastHash == blockValue) {revert();}）</li><li>根据 blockValue/FACTOR 的值判断为正或负，即通过 hash 的首位判断（bool side = coinFlip == 1 ? true : false;）</li></ul></li></ul><p>如果使用可以被挖矿的矿工所控制的变量，如区块哈希值，时间戳，区块高低或是 Gas 上限等作为随机数的熵源，产生的随机数并不安全。</p><p>所以Attack</p><p>&lt;!–code￼1–&gt;</p><p>调用10次 attack() 即可。</p><h4 id="使用-Blockhash-的伪随机数"><a class="headerlink" href="#使用-Blockhash-的伪随机数"></a>使用 Blockhash 的伪随机数</h4><h5 id="原理-4"><a class="headerlink" href="#原理-4"></a>原理</h5><p>Blockhash 是一个特殊的区块变量，EVM 只能获取到当前区块之前的 256 个区块的 blockhash （<strong>不含当前区块</strong>），对于这 256 个之外的区块返回 0。使用 blockhash 可能存在几种问题。</p><ol><li>误用，如 <code>block.blockhash(block.number)</code> 恒为零。</li><li>使用过去区块的有效 blockhash ，可以编写攻击合约获取相同值。</li><li>将猜数字和开奖的交易分开在两个不同区块中，并且使用猜数字时还不知道的某个区块的 blockhash 作为熵源，则可以等待 256 个区块后再进行开奖，消除 blockhash 的不确定性。</li></ol><h4 id="回滚攻击"><a class="headerlink" href="#回滚攻击"></a>回滚攻击</h4><h5 id="原理-5"><a class="headerlink" href="#原理-5"></a>原理</h5><p>在某些情况下，获取随机数可能过于困难或繁琐，这时可以考虑使用回滚攻击。回滚攻击的思想很简单：完全碰运气，输了就 “耍赖”，通过抛出异常使整个交易回滚不作数；赢的时候则不作处理，让交易被正常确认。</p><h4 id="题目"><a class="headerlink" href="#题目"></a>题目</h4><p>0ctf final 2018 : ZeroLottery</p><p>Your goal is make your ZeroLottery’s balance &gt; 500. After that, you can get the flag at <a href="http://192.168.201.18:5000/flag?wallet=">http://192.168.201.18:5000/flag?wallet=</a> page.</p><p>&lt;!–code￼2–&gt;</p><p>分析：</p><p>ZeroLottery()  定义owner；</p><p>init() 初始化余额为100；</p><p>seed() 定义生成随机数函数；</p><p>bet() 进行下注，猜对了扣除0.5，余额清零；猜对了扣除1 ether，余额加上100；</p><p>paolu() 用来销毁合约，只能合约的拥有者能调用；</p><p>本题的目标是余额为500代币。</p><h6 id="EXP1"><a class="headerlink" href="#EXP1"></a>EXP1</h6><p>伪随机数攻击</p><p>block.coinbase, block.difficulty, block.gaslimit, block.timestamp来产生seed，因此区块变量是可以在本地计算出来的。</p><p>由于进行转账操作需要在攻击合约设置fallback函数</p><p>&lt;!–code￼3–&gt;</p><p>如果要求传的钱&gt;1 ether，而且猜完最多会退1ether，因此相当于一定会退钱回我们的攻击合约，攻击五次即可。</p><h6 id="EXP2"><a class="headerlink" href="#EXP2"></a>EXP2</h6><p>回滚攻击</p><p>&lt;!–code￼4–&gt;</p><p>同样可以利用循环：</p><p>&lt;!–code￼5–&gt;</p><p>既然是失败是扣0.5，成功扣1eth，那么如果回退的钱数与失败的一样，那么就抛出异常。</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Integer Overflow and Underflow</title>
      <link href="/2023/10/21/Integer-Overflow-and-Underflow/"/>
      <url>/2023/10/21/Integer-Overflow-and-Underflow/</url>
      
        <content type="html"><![CDATA[<h4 id="原理"><a class="headerlink" href="#原理"></a>原理</h4><p>EVM的整数有int和uint两种。</p><p>在 <code>Solidity</code> 语言中,变量支持的整数类型步长是以8递增的,从 <code>uint8</code> 到 <code>uint256</code>, <code>uint</code> 默认是 <code>uint256</code>,以 <code>uin8</code> 为例</p><p>我们知道 <code>uint8</code> 是8位,我们最多可以 <code>2**8-1</code>,也就是 255,若是256则会造成溢出,这是上溢</p><p>下溢也是一样的, <code>uint(0)-1</code> 就是255</p><h4 id="例子"><a class="headerlink" href="#例子"></a>例子</h4><p>Capture The Ether 的 Token sale</p><p>&lt;!–code￼0–&gt;</p><p>分析：<br>首先规定了合约中有1 ether，一个代币需要支付1 ether. 而isComplete()要求余额小于1 ether。</p><p>buy(uint256 numTokens)函数则是msg.value == numTokens * PRICE_PER_TOKEN。</p><p>再EVM里1ether=10* *8 wei。然而EVM虚拟机最大只有256位即    2**256-1.因此只要我们的numTokens是一个很大的值，就会溢出。即我们花费不足1etner就买到了大量的代币，将一些代币卖出即可完成题目要求。</p><p>因此，我们可以购买2**256//10* *18+1 个代币就可以完成题目要求。</p><p>整数下溢</p><p>&lt;!–code￼1–&gt;</p><p>分析：</p><p>由于uint为无符号类型，因此</p><p>balanceOf[msg.sender] - amount &gt;= 0看似没有任何问题，但是由于都是无符号类型，因此结果永远大于等于0的。所以我们可以任意取款。应改为balanceOf[msg.sender] &gt;=amount</p><p>还有一种情况，与重入攻击有关：将1的物品卖出两次导致下溢为巨大的正数。</p><h4 id="题目"><a class="headerlink" href="#题目"></a>题目</h4><h5 id="【ciscn2019】-Daysbank"><a class="headerlink" href="#【ciscn2019】-Daysbank"></a>【ciscn2019】 Daysbank</h5><p>&lt;!–code￼2–&gt;</p><p>分析：</p><p>找到flag的函数payforflag（），观察得到，要想得到flag需要balanceof大于10w。</p><p>而transfer2（）函数中balanceOf[msg.sender]-howmuch&gt;0存在整数下溢的漏洞，因而可以利用。但是需要满足balanceOf[msg.sender]&gt;2的要求。</p><p>我们可以通过getgift()来获得一个代币，然后可以满足profit（）的要求，从而获得两个代币 ，此时balanceOf为2，gift为1。如果要达到balanceOf[msg.sender]&gt;2，那么需要利用transfer（）函数才能达到要求，transfer没有下溢的漏洞。</p><p>攻击过程：<br>先利用账号a，通过getgift()，然后利用profit（）函数，此时余额为2，gift为1.</p><p>然后再用账号b，重复该操作。</p><p>再将账号a利用transfer函数转给账号b两个代币。</p><p>然后再利用账号b调用transfer2转给账号a一个非常大的金额，达到溢出的效果，此时两个地址都可以执行flag函数。</p>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BASE64</title>
      <link href="/2023/10/20/BASE64/"/>
      <url>/2023/10/20/BASE64/</url>
      
        <content type="html"><![CDATA[<p>BASE64</p><p>&lt;!–code￼0–&gt;</p><p>解码得到 daidrhouse，然而编码得到</p><p>&lt;!–code￼1–&gt;</p><p>发现每一串的第二位都发生了改变，但是结果没变。</p><h4 id="base64原理"><a class="headerlink" href="#base64原理"></a>base64原理</h4><p>顾名思义，base64编码就是用64个ascii字符作为基础来编码二进制内容的一种编码方式。相信各位一定在网页中看到过base64编码的内嵌图片，甚至QQ音乐传输歌词文件时，也采用了base64编码。将二进制编码为ascii字符，使数据在某些场景下更便于阅读、便于传输。当然，将所有二进制「浓缩」到区区64个字符来表示，一定会在体积上作出妥协。字符在编码完成后，会增大1/3倍。</p><p>由于只用到了<strong>64个字符</strong>，所以使用6个二进制位(2^6 = 64)完全可以把所有的字符表示出来，于是原来的1个字节8位在base64编码中变成了1个字节6位。</p><p>换言之：把原本的3个字节变成现在的4个字节，因为(<code>3*8 == 4*6</code>)</p><h4 id="索引表"><a class="headerlink" href="#索引表"></a>索引表</h4><p>base64有一张标准编码表，为64个ascii字符排序并赋予索引。</p><table><thead><tr><th style="text-align:left">索引</th><th style="text-align:left">字符</th><th style="text-align:left">索引</th><th style="text-align:left">字符</th><th style="text-align:left">索引</th><th style="text-align:left">字符</th><th style="text-align:left">索引</th><th style="text-align:left">字符</th></tr></thead><tbody><tr><td style="text-align:left">0</td><td style="text-align:left">A</td><td style="text-align:left">16</td><td style="text-align:left">Q</td><td style="text-align:left">32</td><td style="text-align:left">g</td><td style="text-align:left">48</td><td style="text-align:left">w</td></tr><tr><td style="text-align:left">1</td><td style="text-align:left">B</td><td style="text-align:left">17</td><td style="text-align:left">R</td><td style="text-align:left">33</td><td style="text-align:left">h</td><td style="text-align:left">49</td><td style="text-align:left">x</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">C</td><td style="text-align:left">18</td><td style="text-align:left">S</td><td style="text-align:left">34</td><td style="text-align:left">i</td><td style="text-align:left">50</td><td style="text-align:left">y</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">D</td><td style="text-align:left">19</td><td style="text-align:left">T</td><td style="text-align:left">35</td><td style="text-align:left">j</td><td style="text-align:left">51</td><td style="text-align:left">z</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">E</td><td style="text-align:left">20</td><td style="text-align:left">U</td><td style="text-align:left">36</td><td style="text-align:left">k</td><td style="text-align:left">52</td><td style="text-align:left">0</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">F</td><td style="text-align:left">21</td><td style="text-align:left">V</td><td style="text-align:left">37</td><td style="text-align:left">l</td><td style="text-align:left">53</td><td style="text-align:left">1</td></tr><tr><td style="text-align:left">6</td><td style="text-align:left">G</td><td style="text-align:left">22</td><td style="text-align:left">W</td><td style="text-align:left">38</td><td style="text-align:left">m</td><td style="text-align:left">54</td><td style="text-align:left">2</td></tr><tr><td style="text-align:left">7</td><td style="text-align:left">H</td><td style="text-align:left">23</td><td style="text-align:left">X</td><td style="text-align:left">39</td><td style="text-align:left">n</td><td style="text-align:left">55</td><td style="text-align:left">3</td></tr><tr><td style="text-align:left">8</td><td style="text-align:left">I</td><td style="text-align:left">24</td><td style="text-align:left">Y</td><td style="text-align:left">40</td><td style="text-align:left">o</td><td style="text-align:left">56</td><td style="text-align:left">4</td></tr><tr><td style="text-align:left">9</td><td style="text-align:left">J</td><td style="text-align:left">25</td><td style="text-align:left">Z</td><td style="text-align:left">41</td><td style="text-align:left">p</td><td style="text-align:left">57</td><td style="text-align:left">5</td></tr><tr><td style="text-align:left">10</td><td style="text-align:left">K</td><td style="text-align:left">26</td><td style="text-align:left">a</td><td style="text-align:left">42</td><td style="text-align:left">q</td><td style="text-align:left">58</td><td style="text-align:left">6</td></tr><tr><td style="text-align:left">11</td><td style="text-align:left">L</td><td style="text-align:left">27</td><td style="text-align:left">b</td><td style="text-align:left">43</td><td style="text-align:left">r</td><td style="text-align:left">59</td><td style="text-align:left">7</td></tr><tr><td style="text-align:left">12</td><td style="text-align:left">M</td><td style="text-align:left">28</td><td style="text-align:left">c</td><td style="text-align:left">44</td><td style="text-align:left">s</td><td style="text-align:left">60</td><td style="text-align:left">8</td></tr><tr><td style="text-align:left">13</td><td style="text-align:left">N</td><td style="text-align:left">29</td><td style="text-align:left">d</td><td style="text-align:left">45</td><td style="text-align:left">t</td><td style="text-align:left">61</td><td style="text-align:left">9</td></tr><tr><td style="text-align:left">14</td><td style="text-align:left">O</td><td style="text-align:left">30</td><td style="text-align:left">e</td><td style="text-align:left">46</td><td style="text-align:left">u</td><td style="text-align:left">62</td><td style="text-align:left">+</td></tr><tr><td style="text-align:left">15</td><td style="text-align:left">P</td><td style="text-align:left">31</td><td style="text-align:left">f</td><td style="text-align:left">47</td><td style="text-align:left">v</td><td style="text-align:left">63</td><td style="text-align:left">/</td></tr></tbody></table><p>有时为了防止混淆（比如链接），会使用 <code>.</code> <code>_</code> 来代替索引表中的 <code>+</code> <code>/</code> 。</p><h4 id="隐写原理"><a class="headerlink" href="#隐写原理"></a>隐写原理</h4><p>base64在解码的时候，会按照字符串末尾的 <code>=</code> 数量来删除相应字节数。或许你已经发现了，当一组字符的数量为1字节或2字节的时候，会有4位或2位二进制在解码时被忽略</p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030924270.png" alt loading="lazy"></p><p><img src="https://cdn.jsdelivr.net/gh/xiaoxiaoxiaoxiaocai/Drawing-bed/draw-bed/202406030924272.png" alt loading="lazy"></p><p>即解码时：</p><p>解密的时候首先把&quot;=&quot;删去，然后写出二进制数串，然后从左往右每8位一组，剩余的不足8位丢掉，然后根据转换表获得相应字符</p><p>然后每8位一组，剩余不足的丢弃，</p><p>也就是说红色部分会被忽略，所以即使对其进行改变，解码得到的结果依然不变。</p><p>解密得到的明文是不变的，那么你重新按照正确的加密流程计算一遍，如果发现结果不一样，那么就说明隐藏进了信息。</p><p>CTF题目中出现一大堆base64编码字符串的时候，更需要考虑base64隐写。</p><p>base64的解密脚本</p><p>&lt;!–code￼2–&gt;</p><p>加密脚本：</p><p>&lt;!–code￼3–&gt;</p><h4 id="NewstarCtf-2023"><a class="headerlink" href="#NewstarCtf-2023"></a>NewstarCtf 2023</h4><h5 id="base"><a class="headerlink" href="#base"></a>base!</h5><p>脚本解码得到</p><p>iDMb6ZMnTFMtFuouYZHwPTYAoWjC7Hjca8</p><p>即flag{b4se_1s_4_g0od_c0d3}</p><h4 id="base家族"><a class="headerlink" href="#base家族"></a>base家族</h4><p><a href="http://www.atoolbox.net/Tool.php?Id=934">http://www.atoolbox.net/Tool.php?Id=934</a></p><p><a href="https://ctf.bugku.com/tools">https://ctf.bugku.com/tools</a></p>]]></content>
      
      
      <categories>
          
          <category> Misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Re-Entrancy</title>
      <link href="/2023/10/19/Re-Entrancy/"/>
      <url>/2023/10/19/Re-Entrancy/</url>
      
        <content type="html"><![CDATA[<p>重入攻击是智能合约的经典攻击。</p><h2 id="原理"><a class="headerlink" href="#原理"></a>原理</h2><p>fallback函数是一个特殊的结构，在特定情况下会被触发。</p><p>特点：</p><ol><li>不被命名</li><li>被外部调用，不能被自己合约的函数调用</li><li>一个合约至多只有一个fallback函数</li><li>会在别的合约调用一个本合约没有的函数调用</li><li>当eth被发送给这个合约是没有calldata同时没有receive函数，fallback是会被触发，要设置为payable</li><li>可以包含自己的逻辑</li></ol><p>下述行为消耗的gas都将超过fallback函数限定的gas值：</p><ul><li>向区块链中写数据</li><li>创建一个合约</li><li>调用一个external的函数</li><li>发送ether</li></ul><p>如果没有足够的Gas，是不足以支持不断重入的。<code>call.value()</code>转账给了我们足够的Gas。</p><p><code>&lt;address&gt;.transfer(uint256 amount)</code>:<br>向 地址类型 发送数量为 amount 的 Wei，失败时抛出 <strong>异常</strong>，发送 2300 gas 的矿工费，不可调节。</p><p><code>&lt;address&gt;.send(uint256 amount)</code>(bool):<br>向 地址类型 发送数量为 amount 的 Wei，失败时返回 <strong>false</strong>，发送 2300 gas 的矿工费用，不可调节。</p><p><code>&lt;address&gt;.call(...)</code> (bool):<br>发出低级函数 CALL，失败时返回 false，发送所有可用 gas，可调节。<br><code>.call</code>函数添加<code>.value</code>会附加上代币，形成转账</p><p>&lt;!–code￼0–&gt;</p><p>当balanceof充足时，就会调用转账功能。这个问题是，先转账再记账，若再次调用fallback（）函数，此时balanceof还未减少就会无限调用，可能导致gas不够用，因此需要限制次数。</p><p>&lt;!–code￼1–&gt;</p><h2 id="题目"><a class="headerlink" href="#题目"></a>题目</h2><h3 id="【强网杯2019】babybank"><a class="headerlink" href="#【强网杯2019】babybank"></a>【强网杯2019】babybank</h3><p>&lt;!–code￼2–&gt;</p><p>pay for flag<br>function payforflag(string md5ofteamtoken,string b64email) public{<br>require(balance[msg.sender] &gt;= 10000000000);<br>balance[msg.sender]=0;<br>owner.transfer(address(this).balance);<br>emit sendflag(md5ofteamtoken,b64email);<br>}</p><p>当balance超过10000000000是就会触发flag函数。</p><p>发现withdraw函数发现重入漏洞 msg.sender.call.value(amount*100000000000000)();，可以配合整数下溢漏洞从而达到balance的要求。</p><p>要完成withdraw()函数需要完成三个挑战。</p><p>第一个是profit函数</p><p>require(level[msg.sender]= =0);<br>require(uint(msg.sender) &amp; 0xffff==0xb1b1);</p><p>首先需要调用者level为0，其次需要调用者的后四位为b1b1，</p><p>level原本就是0，而后四位则可以通过网站生成固定账号，<a href="https://vanity-eth.tk/">Vanity-ETH | Ethereum vanity address generator</a></p><p>，即可绕过，此时balance以及level都为1，此时来到挑战2.</p><p>挑战2，需要猜到的与设置的guess相同。serect的值可以在合约的部署中找到。合约部署者的最后一次交易的inputdata桉树选择器前四个字节为函数的签名参数就是部署这传入的参数。</p><p>然后就可以调用withdraw函数。</p><p>但是由于合约没有任何blance因此需要先进行转账。</p><p>可以用selfdestruct函数来进行充值。</p><p>攻击合约</p><p>&lt;!–code￼3–&gt;</p><ol><li>由于合约本身没有以太币，所以我们先生成合约A调用自杀函数给题目转钱。</li><li>进行转账操作，我们使用账户B分别调用profit()、guess()、transfer()给C账户转2token。</li><li>当C有了2token便可以进行攻击，调用hacker函数即可。</li></ol>]]></content>
      
      
      <categories>
          
          <category> Blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Attack </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
