### 图片隐写

#### 附加式的图片隐写

##### 附加字符串

附加方法

- winhex直接附加再保存
- `copy /b a.jpg+b.txt c.jpg`，在a图片里加b的内容，得到c图片

识别方法

- winhex直接看
- notepad也可以看
- linux的strings指令

应用

- 制作图片马，即把木马放到图片的最后



#### 基于文件结构的图片隐写

主要是png

文件结构应包括

png文件标志

png数据块：关键数据块和辅助数据块，其中正常的关键数据块有长度、数据块类型码、数据块数据和CRC这4种

##### （1）png图片文件头数据块（IHDR）

包括了图片的宽，高，图像深度，颜色类型，压缩方法等信息

它由第11——32字节组成（从0开始），包含有 PNG 文件中存储的图像数据的基本信息，数据从第 16字节开始，有13个字节，其前8字节分别用4个字节规定了图片的宽和高（十六进制，以像素为单位）。

**IHDR** 的前8字节规定了图片的宽和高，我们可以用十六进位文件编辑器更改它们以使得这张图片显示不完整，从而达到隐藏信息的目的。

```python
import os
import binascii
import struct

crcbp = open("D:\\桌面文件\\bingbing.png", "rb").read()    #打开图片
for i in range(2000):
    for j in range(2000):
        data = crcbp[12:16] + \
            struct.pack('>i', i)+struct.pack('>i', j)+crcbp[24:29]
        crc32 = binascii.crc32(data) & 0xffffffff
        if(crc32 == 0xda5a4a50):    #图片当前CRC
            print(i, j)
            print('hex:', hex(i), hex(j))


```













#### PNG

#### 文件格式

文件：文件头`89 50 4E 47 0D 0A 1A 0A` + 数据块 + 数据块 + 数据块……

#### 数据块 CHUNK

每个数据块都有四个部分组成。

| 名称                            | 字节数   | 说明                                                 |
| :------------------------------ | :------- | :--------------------------------------------------- |
| Length（长度）                  | 4 字节   | 指定数据块中数据域的长度，其长度不超过（231－1）字节 |
| Chunk Type Code（数据块类型码） | 4 字节   | 数据块类型码由 ASCII 字母（A - Z 和 a - z）组成      |
| Chunk Data（数据块数据）        | 可变长度 | 存储按照 Chunk Type Code 指定的数据                  |
| CRC（循环冗余检测）             | 4 字节   | 存储用来检测是否有错误的循环冗余码                   |

##### 关键数据块

每个PNG都必须包括。

###### IHDR

 文件头数据块：包含PNG储存的图像的基本信息。由13个字节组成。一个PNG数据流中只能有一个。

PNG图片固定以 89 50 4E 47 0D 0A 1A 0A （4个字节）开头

接下来是IHDR区，这个区标识着PNG文件的属性参数，如长宽、色彩模式等，具体如下：

08-0B：4个字节标识IHDR区的大小（注意是去掉tag和crc32后的大小），这里为00 00 00 0D，即13个字节。

0C-0F：4个字节，固定为49 48 44 52(IHDR) 标识该区为IHDR区
10-13：4个字节，图片宽度。
14-17：4个字节，图片高度。
18：1个字节 图像深度。
19：1个字节 颜色类型。
1A：1个字节 压缩算法。
1B：1个字节 滤波方法。
1C：1个字节 隔行扫描。

1D-20：4个字节，crc32校验值。

前八字节.

| 域的名称 | 字节数  | 说明                   |
| :------- | :------ | :--------------------- |
| Width    | 4 bytes | 图像宽度，以像素为单位 |
| Height   | 4 bytes | 图像高度，以像素为单位 |

可以修改图片的高度和宽度发现隐藏的字符串。

 文件宽度和高度不能任意修改，需要根据 IHDR 块的 CRC 值爆破得到宽度和高度。

爆破宽度的脚本

```python
import os
import binascii
import struct


misc = open("misc4.png","rb").read()

for i in range(1024):
    data = misc[12:16] + struct.pack('>i',i)+ misc[20:29]
    crc32 = binascii.crc32(data) & 0xffffffff
    if crc32 == 0x932f8a6b:
        print i
```

爆破宽高的脚本

```python
import zlib
import struct

filename=''     #图片路径
crc_str= ''     #图片的CRC值（16进制字符串，如'0xc4ed3'）

# 同时暴破宽度和高度
with open(filename, 'rb') as f:
    all_b = f.read()
    data = bytearray(all_b[12:29])
    n = 4095
    for w in range(n):
        width = bytearray(struct.pack('>i', w))
        for h in range(n):
            height = bytearray(struct.pack('>i', h))
            for x in range(4):
                data[x+4] = width[x]
                data[x+8] = height[x]
            crc32result = zlib.crc32(data)
            #替换成图片的crc
            if crc32result == int(crc_str,16):
                print("宽为：", end = '')
                print(width, end = ' ')
                print(int.from_bytes(width, byteorder='big'))
                print("高为：", end = '')
                print(height, end = ' ')
                print(int.from_bytes(height, byteorder='big')) 
```

###### PLTE

与索引彩色图像有关。而且要放在图像数据块（image data chunk）之前。真彩色的 PNG 数据流也可以有调色板数据块，目的是便于非真彩色显示程序用它来量化图像数据，从而显示该图像。

###### IDAT

图像数据块 IDAT（image data chunk）：它存储实际的数据，在数据流中可包含多个连续顺序的图像数据块。

- 储存图像像数数据
- 在数据流中可包含多个连续顺序的图像数据块
- 采用 LZ77 算法的派生算法进行压缩
- 可以用 zlib 解压缩

值得注意的是，IDAT 块只有当上一个块充满时，才会继续一个新的块。

用 `pngcheck` 去查看此 PNG 文件

利用 `python zlib` 解压多余 IDAT 块的内容，此时注意剔除 **长度、数据块类型及末尾的 CRC 校验值**。

```python
import zlib
import binascii
IDAT = "789...667".decode('hex')
result = binascii.hexlify(zlib.decompress(IDAT))
print result
```

###### IEND

用来标记                 png或数据流已经结束，必须放在文件尾部。

00 00 00 00 49 45 4E 44 AE 42 60 82

长度为00 00 00 00，数据标识 49 45 4E 44，CRC AE42 60 82.

##### LSB

全称最低有效位。

一般PNG文件中的图像数一般由RGB三原色组成，每一种颜色占用八位（即8bit），取值0x00到0xFF即256中，一共包含了256的3次方种颜色。

人类眼睛能区分的颜色数有限。

LSB隐写就是修改RGB颜色分量中的最低二进制位，修改的就是像数中的1 bit 位。人类眼睛不会注意到这前后的变化。

LSB可以借助Stegsolve查看各个通道。

助 `Stegsolve-->Analyse-->Data Extract` 可以指定通道进行提取。

##### 题目

###### ctfshow misc51

图片隐写颜色通道。

利用stegsolve工具在Red plane1，Green plane 0，Blue plane2.

拼凑得出flag		

####  JPG

##### 文件结构

有损压缩格式，将像素用jpeg保存成文件后再读取出来，某些像素会有少许变化。保存时有可以选择的质量参数，参数越大，图片就越保真。

基本数据结构分为：  段和经过压缩编码的图像数据。

| 名 称   | 字节数 | 数据 | 说明                                         |
| :------ | :----- | :--- | :------------------------------------------- |
| 段 标识 | 1      | FF   | 每个新段的开始标识                           |
| 段类型  | 1      |      | 类型编码（称作标记码）                       |
| 段长 度 | 2      |      | 包括段内容和段长度本身, 不包括段标识和段类型 |
| 段内容  | 2      |      | ≤65533 字节                                  |

- 有些段没有长度描述也没有内容，只有段标识和段类型。文件头和文件尾均属于这种段。
- 段与段之间无论有多少 `FF` 都是合法的，这些 `FF` 称为「填充字节」，必须被忽略掉。

`0xffd8` 和 `0xffd9`为 JPG 文件的开始结束的标志。

#### BMP

- `biSize`：表示文件信息头的大小，一般为 40（字节）。
- `biWidth`：表示图像的宽度，以像素为单位。
- `biHeight`：表示图像的高度，以像素为单位。需要特别注意的是，当该值为正数时，表示图像顶部在文件中的位置为位图文件的起始位置，而图像底部则在文件的末尾；当该值为负数时，表示图像底部在文件中的位置为位图文件的起始位置，而图像顶部则在文件的末尾。
- `biPlanes`：表示位图的平面数，始终为 1。
- `biBitCount`：表示每个像素所占用的位数，一般为 8、16、24 或 32 位。在 8 位的 BMP 图像中，每个像素值占用一个字节，可以表示 256 种不同的颜色，而在 24 位的 BMP 图像中，每个像素由 3 个字节组成，分别表示红、绿、蓝三原色的色值，可以表示约 1670 万种不同的颜色。
- `biCompression`：表示压缩类型，一般为 0（不压缩）。
- `biSizeImage`：表示图像数据的大小，以字节为单位，一般可通过文件大小减去文件头大小计算得到。
- `biXPelsPerMeter`：表示水平分辨率，以像素每米为单位。
- `biYPelsPerMeter`：表示垂直分辨率，以像素每米为单位。
- `biClrUsed`：表示调色板的颜色数量，如果该值为 0，则表示使用所有颜色。
- `biClrImportant`：表示重要的调色板索引，如果该值为 0，则表示所有颜色都是重要的。

#### 零宽字符隐写

[零宽度字符隐写 | Lazzaro (lazzzaro.github.io)](https://lazzzaro.github.io/2020/05/24/misc-零宽度字符隐写/index.html)
